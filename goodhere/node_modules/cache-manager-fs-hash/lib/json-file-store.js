"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

const _require = require('es6-promisify'),
      promisify = _require.promisify;

const fs = require('fs');

exports.write =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (path, data) {
    const externalBuffers = [];
    const dataString = JSON.stringify(data, function replacerFunction(k, value) {
      //Buffers searilize to {data: [...], type: "Buffer"}
      if (value && value.type === 'Buffer' && value.data && value.data.length >= 1024
      /* only save bigger Buffers external, small ones can be inlined */
      ) {
          const buffer = Buffer.from(value.data);
          externalBuffers.push({
            index: externalBuffers.length,
            buffer: buffer
          });
          return {
            type: 'ExternalBuffer',
            index: externalBuffers.length - 1,
            size: buffer.length
          };
        } else {
        return value;
      }
    }); //save main json file

    yield promisify(fs.writeFile)(path + '.json', dataString, 'utf8'); //save external buffers

    yield Promise.all(externalBuffers.map(
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (externalBuffer) {
        yield promisify(fs.writeFile)(path + '-' + externalBuffer.index + '.bin', externalBuffer.buffer, 'utf8');
      });

      return function (_x3) {
        return _ref2.apply(this, arguments);
      };
    }()));
  });

  return function (_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.read =
/*#__PURE__*/
function () {
  var _ref3 = _asyncToGenerator(function* (path) {
    //read main json file
    const dataString = yield promisify(fs.readFile)(path + '.json', 'utf8');
    const externalBuffers = [];
    const data = JSON.parse(dataString, function bufferReceiver(k, value) {
      if (value && value.type === 'Buffer' && value.data) {
        return Buffer.from(value.data);
      } else if (value && value.type === 'ExternalBuffer' && typeof value.index === 'number' && typeof value.size === 'number') {
        //JSON.parse is sync so we need to return a buffer sync, we will fill the buffer later
        const buffer = Buffer.alloc(value.size);
        externalBuffers.push({
          index: +value.index,
          buffer: buffer
        });
        return buffer;
      } else {
        return value;
      }
    }); //read external buffers

    yield Promise.all(externalBuffers.map(
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(function* (externalBuffer) {
        const fd = yield promisify(fs.open)(path + '-' + +externalBuffer.index + '.bin', 'r');
        yield promisify(fs.read)(fd, externalBuffer.buffer, 0, externalBuffer.buffer.length, 0);
        yield promisify(fs.close)(fd);
      });

      return function (_x5) {
        return _ref4.apply(this, arguments);
      };
    }()));
    return data;
  });

  return function (_x4) {
    return _ref3.apply(this, arguments);
  };
}();

exports.delete =
/*#__PURE__*/
function () {
  var _ref5 = _asyncToGenerator(function* (path) {
    yield promisify(fs.unlink)(path + '.json'); //delete binary files

    try {
      for (let i = 0; i < Infinity; i++) {
        yield promisify(fs.unlink)(path + '-' + i + '.bin');
      }
    } catch (err) {
      if (err.code === 'ENOENT') {// every binary is deleted, we are done
      } else {
        throw err;
      }
    }
  });

  return function (_x6) {
    return _ref5.apply(this, arguments);
  };
}();