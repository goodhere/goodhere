/// <reference types="node" />
import events from 'events';
import { MultipleQueriesResponse } from '@algolia/client-search';
import { SearchClient } from 'algoliasearch';
import { SearchForFacetValuesResponse } from '@algolia/client-search';
import { SearchResponse } from '@algolia/client-search';

/**
 * Event triggered when a parameter is set or updated
 * @event AlgoliaSearchHelper#event:change
 * @property {object} event
 * @property {SearchParameters} event.state the current parameters with the latest changes applied
 * @property {SearchResults} event.results the previous results received from Algolia. `null` before the first request
 * @example
 * helper.on('change', function(event) {
 *   console.log('The parameters have changed');
 * });
 */
/**
 * Event triggered when a main search is sent to Algolia
 * @event AlgoliaSearchHelper#event:search
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search
 * @property {SearchResults} event.results the results from the previous search. `null` if it is the first search.
 * @example
 * helper.on('search', function(event) {
 *   console.log('Search sent');
 * });
 */
/**
 * Event triggered when a search using `searchForFacetValues` is sent to Algolia
 * @event AlgoliaSearchHelper#event:searchForFacetValues
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search it is the first search.
 * @property {string} event.facet the facet searched into
 * @property {string} event.query the query used to search in the facets
 * @example
 * helper.on('searchForFacetValues', function(event) {
 *   console.log('searchForFacetValues sent');
 * });
 */
/**
 * Event triggered when a search using `searchOnce` is sent to Algolia
 * @event AlgoliaSearchHelper#event:searchOnce
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search it is the first search.
 * @example
 * helper.on('searchOnce', function(event) {
 *   console.log('searchOnce sent');
 * });
 */
/**
 * Event triggered when the results are retrieved from Algolia
 * @event AlgoliaSearchHelper#event:result
 * @property {object} event
 * @property {SearchResults} event.results the results received from Algolia
 * @property {SearchParameters} event.state the parameters used to query Algolia. Those might be different from the one in the helper instance (for example if the network is unreliable).
 * @example
 * helper.on('result', function(event) {
 *   console.log('Search results received');
 * });
 */
/**
 * Event triggered when Algolia sends back an error. For example, if an unknown parameter is
 * used, the error can be caught using this event.
 * @event AlgoliaSearchHelper#event:error
 * @property {object} event
 * @property {Error} event.error the error returned by the Algolia.
 * @example
 * helper.on('error', function(event) {
 *   console.log('Houston we got a problem.');
 * });
 */
/**
 * Event triggered when the queue of queries have been depleted (with any result or outdated queries)
 * @event AlgoliaSearchHelper#event:searchQueueEmpty
 * @example
 * helper.on('searchQueueEmpty', function() {
 *   console.log('No more search pending');
 *   // This is received before the result event if we're not expecting new results
 * });
 *
 * helper.search();
 */
/**
 * Initialize a new AlgoliaSearchHelper
 * @class
 * @classdesc The AlgoliaSearchHelper is a class that ease the management of the
 * search. It provides an event based interface for search callbacks:
 *  - change: when the internal search state is changed.
 *    This event contains a {@link SearchParameters} object and the
 *    {@link SearchResults} of the last result if any.
 *  - search: when a search is triggered using the `search()` method.
 *  - result: when the response is retrieved from Algolia and is processed.
 *    This event contains a {@link SearchResults} object and the
 *    {@link SearchParameters} corresponding to this answer.
 *  - error: when the response is an error. This event contains the error returned by the server.
 * @param  {AlgoliaSearch} client an AlgoliaSearch client
 * @param  {string} index the index name to query
 * @param  {SearchParameters | object} options an object defining the initial
 * config of the search. It doesn't have to be a {SearchParameters},
 * just an object containing the properties you need from it.
 */
declare class AlgoliaSearchHelper extends events.EventEmitter {
    state: SearchParameters;
    lastResults: SearchResults | null;
    derivedHelpers: DerivedHelper[];
    client: SearchClient;
    _queryId: number;
    _lastQueryIdReceived: number;
    _currentNbQueries: number;
    constructor(client: SearchClient, index: string, options: SearchParameters);
    /**
     * Start the search with the parameters set in the state. When the
     * method is called, it triggers a `search` event. The results will
     * be available through the `result` event. If an error occurs, an
     * `error` will be fired instead.
     * @return {AlgoliaSearchHelper}
     * @fires search
     * @fires result
     * @fires error
     * @chainable
     */
    search(): this;
    searchOnlyWithDerivedHelpers(): this;
    /**
     * Gets the search query parameters that would be sent to the Algolia Client
     * for the hits
     * @return {object} Query Parameters
     */
    getQuery(): any;
    /**
     * Start a search using a modified version of the current state. This method does
     * not trigger the helper lifecycle and does not modify the state kept internally
     * by the helper. This second aspect means that the next search call will be the
     * same as a search call before calling searchOnce.
     * @param {object} options can contain all the parameters that can be set to SearchParameters
     * plus the index
     * @param {function} [callback] optional callback executed when the response from the
     * server is back.
     * @return {promise|undefined} if a callback is passed the method returns undefined
     * otherwise it returns a promise containing an object with two keys :
     *  - content with a SearchResults
     *  - state with the state used for the query as a SearchParameters
     * @example
     * // Changing the number of records returned per page to 1
     * // This example uses the callback API
     * var state = helper.searchOnce({hitsPerPage: 1},
     *   function(error, content, state) {
     *     // if an error occurred it will be passed in error, otherwise its value is null
     *     // content contains the results formatted as a SearchResults
     *     // state is the instance of SearchParameters used for this search
     *   });
     * @example
     * // Changing the number of records returned per page to 1
     * // This example uses the promise API
     * var state1 = helper.searchOnce({hitsPerPage: 1})
     *                 .then(promiseHandler);
     *
     * function promiseHandler(res) {
     *   // res contains
     *   // {
     *   //   content : SearchResults
     *   //   state   : SearchParameters (the one used for this specific search)
     *   // }
     * }
     */
    searchOnce(options: SearchParameters): Promise<{
        content: SearchResults;
        state: SearchParameters;
    }>;
    searchOnce(options: SearchParameters, cb: (error: Error | null, content: SearchResults | null, state: SearchParameters) => void): void;
    /**
     * Structure of each result when using
     * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)
     * @typedef FacetSearchHit@typedef FacetSearchHit
     * @type {object}
     * @property {string} value the facet value
     * @property {string} highlighted the facet value highlighted with the query string
     * @property {number} count number of occurrence of this facet value
     * @property {boolean} isRefined true if the value is already refined
     */
    /**
     * Structure of the data resolved by the
     * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)
     * promise.
     * @typedef FacetSearchResult@typedef FacetSearchResult
     * @type {object}
     * @property {FacetSearchHit} facetHits the results for this search for facet values
     * @property {number} processingTimeMS time taken by the query inside the engine
     */
    /**
     * Search for facet values based on an query and the name of a faceted attribute. This
     * triggers a search and will return a promise. On top of using the query, it also sends
     * the parameters from the state so that the search is narrowed down to only the possible values.
     *
     * See the description of [FacetSearchResult](reference.html#FacetSearchResult)
     * @param {string} facet the name of the faceted attribute
     * @param {string} query the string query for the search
     * @param {number} [maxFacetHits] the maximum number values returned. Should be > 0 and <= 100
     * @param {object} [userState] the set of custom parameters to use on top of the current state. Setting a property to `undefined` removes
     * it in the generated query.
     * @return {promise.<FacetSearchResult>} the results of the search
     */
    searchForFacetValues(facet: string, query: string, maxFacetHits: number, userState: Partial<SearchParameters>): Promise<SearchForFacetValuesResponse>;
    /**
     * Sets the text query used for the search.
     *
     * This method resets the current page to 0.
     * @param  {string} q the user query
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setQuery(q: string): this;
    /**
     * Remove all the types of refinements except tags. A string can be provided to remove
     * only the refinements of a specific attribute. For more advanced use case, you can
     * provide a function instead. This function should follow the
     * [clearCallback definition](#SearchParameters.clearCallback).
     *
     * This method resets the current page to 0.
     * @param {string} [name] optional name of the facet / attribute on which we want to remove all refinements
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     * @example
     * // Removing all the refinements
     * helper.clearRefinements().search();
     * @example
     * // Removing all the filters on a the category attribute.
     * helper.clearRefinements('category').search();
     * @example
     * // Removing only the exclude filters on the category facet.
     * helper.clearRefinements(function(value, attribute, type) {
     *   return type === 'exclude' && attribute === 'category';
     * }).search();
     */
    clearRefinements(name: string): this;
    /**
     * Remove all the tag filters.
     *
     * This method resets the current page to 0.
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    clearTags(): this;
    /**
     * Adds a disjunctive filter to a faceted attribute with the `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value (will be converted to string)
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addDisjunctiveFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addDisjunctiveFacetRefinement}
     */
    addDisjunctiveRefine(facet: string, value: string): this;
    /**
     * Adds a refinement on a hierarchical facet. It will throwarguments
     * an exception if the facet is not defined or if the facet
     * is already refined.
     *
     * This method resets the current page to 0.
     * @param {string} facet the facet name
     * @param {string} path the hierarchical facet path
     * @return {AlgoliaSearchHelper}
     * @throws Error if the facet is not defined or if the facet is refined
     * @chainable
     * @fires change
     */
    addHierarchicalFacetRefinement(facet: string, value: string): this;
    /**
     * Adds a an numeric filter to an attribute with the `operator` and `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} attribute the attribute on which the numeric filter applies
     * @param  {string} operator the operator of the filter
     * @param  {number} value the value of the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addNumericRefinement(attribute: string, operator: Operator_2, value: number): this;
    /**
     * Adds a filter to a faceted attribute with the `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value (will be converted to string)
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetRefinement}
     */
    addRefine(facet: string, value: string): this;
    /**
     * Adds a an exclusion filter to a faceted attribute with the `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value (will be converted to string)
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addFacetExclusion(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetExclusion}
     */
    addExclude(facet: string, value: string): this;
    /**
     * Adds a tag filter with the `tag` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param {string} tag the tag to add to the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addTag(tag: string): this;
    /**
     * Removes an numeric filter to an attribute with the `operator` and `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * Some parameters are optional, triggering different behavior:
     *  - if the value is not provided, then all the numeric value will be removed for the
     *  specified attribute/operator couple.
     *  - if the operator is not provided either, then all the numeric filter on this attribute
     *  will be removed.
     *
     * This method resets the current page to 0.
     * @param  {string} attribute the attribute on which the numeric filter applies
     * @param  {string} [operator] the operator of the filter
     * @param  {number} [value] the value of the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeNumericRefinement(attribute: string, operator: Operator_2, value: number): this;
    /**
     * Removes a disjunctive filter to a faceted attribute with the `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * If the value is omitted, then this method will remove all the filters for the
     * attribute.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} [value] the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeDisjunctiveFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeDisjunctiveFacetRefinement}
     */
    removeDisjunctiveRefine(facet: string, value: string): this;
    /**
     * Removes the refinement set on a hierarchical facet.
     * @param {string} facet the facet name
     * @return {AlgoliaSearchHelper}
     * @throws Error if the facet is not defined or if the facet is not refined
     * @fires change
     * @chainable
     */
    removeHierarchicalFacetRefinement(facet: string): this;
    /**
     * Removes a filter to a faceted attribute with the `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * If the value is omitted, then this method will remove all the filters for the
     * attribute.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} [value] the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetRefinement}
     */
    removeRefine(facet: string, value: string): this;
    /**
     * Removes an exclusion filter to a faceted attribute with the `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * If the value is omitted, then this method will remove all the filters for the
     * attribute.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} [value] the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeFacetExclusion(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetExclusion}
     */
    removeExclude(facet: string, value: string): this;
    /**
     * Removes a tag filter with the `tag` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param {string} tag tag to remove from the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeTag(tag: string): this;
    /**
     * Adds or removes an exclusion filter to a faceted attribute with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    toggleFacetExclusion(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetExclusion}
     */
    toggleExclude(facet: string, value: string): this;
    /**
     * Adds or removes a filter to a faceted attribute with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method can be used for conjunctive, disjunctive and hierarchical filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     * @throws Error will throw an error if the facet is not declared in the settings of the helper
     * @fires change
     * @chainable
     * @deprecated since version 2.19.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}
     */
    toggleRefinement(facet: string, value: string): this;
    /**
     * Adds or removes a filter to a faceted attribute with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method can be used for conjunctive, disjunctive and hierarchical filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     * @throws Error will throw an error if the facet is not declared in the settings of the helper
     * @fires change
     * @chainable
     */
    toggleFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}
     */
    toggleRefine(facet: string, value: string): this;
    /**
     * Adds or removes a tag filter with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method resets the current page to 0.
     * @param {string} tag tag to remove or add
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    toggleTag(tag: string): this;
    /**
     * Increments the page number by one.
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     * @example
     * helper.setPage(0).nextPage().getPage();
     * // returns 1
     */
    nextPage(): this;
    /**
     * Decrements the page number by one.
     * @fires change
     * @return {AlgoliaSearchHelper}
     * @chainable
     * @example
     * helper.setPage(1).previousPage().getPage();
     * // returns 0
     */
    previousPage(): this;
    /**
     * Change the current page
     * @deprecated
     * @param  {number} page The page number
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setCurrentPage(page: number): this;
    /**
     * Updates the current page.
     * @function
     * @param  {number} page The page number
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setPage: (page: number) => this;
    /**
     * Updates the name of the index that will be targeted by the query.
     *
     * This method resets the current page to 0.
     * @param {string} name the index name
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setIndex(name: string): this;
    /**
     * Update a parameter of the search. This method reset the page
     *
     * The complete list of parameters is available on the
     * [Algolia website](https://www.algolia.com/doc/rest#query-an-index).
     * The most commonly used parameters have their own [shortcuts](#query-parameters-shortcuts)
     * or benefit from higher-level APIs (all the kind of filters and facets have their own API)
     *
     * This method resets the current page to 0.
     * @param {string} parameter name of the parameter to update
     * @param {any} value new value of the parameter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     * @example
     * helper.setQueryParameter('hitsPerPage', 20).search();
     */
    setQueryParameter(parameter: keyof SearchParameters, value: any): this;
    /**
     * Set the whole state (warning: will erase previous state)
     * @param {SearchParameters} newState the whole new state
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setState(newState: Partial<SearchParameters>): this;
    /**
     * Override the current state without triggering a change event.
     * Do not use this method unless you know what you are doing. (see the example
     * for a legit use case)
     * @param {SearchParameters} newState the whole new state
     * @return {AlgoliaSearchHelper}
     * @example
     *  helper.on('change', function(state){
     *    // In this function you might want to find a way to store the state in the url/history
     *    updateYourURL(state)
     *  })
     *  window.onpopstate(event){
     *    // This is naive though as you should check if the state is really defined etc.
     *    helper.overrideStateWithoutTriggeringChangeEvent(event.state).search()
     *  }
     * @chainable
     */
    overrideStateWithoutTriggeringChangeEvent(newState: Partial<SearchParameters>): this;
    /**
     * Check if an attribute has any numeric, conjunctive, disjunctive or hierarchical filters.
     * @param {string} attribute the name of the attribute
     * @return {boolean} true if the attribute is filtered by at least one value
     * @example
     * // hasRefinements works with numeric, conjunctive, disjunctive and hierarchical filters
     * helper.hasRefinements('price'); // false
     * helper.addNumericRefinement('price', '>', 100);
     * helper.hasRefinements('price'); // true
     *
     * helper.hasRefinements('color'); // false
     * helper.addFacetRefinement('color', 'blue');
     * helper.hasRefinements('color'); // true
     *
     * helper.hasRefinements('material'); // false
     * helper.addDisjunctiveFacetRefinement('material', 'plastic');
     * helper.hasRefinements('material'); // true
     *
     * helper.hasRefinements('categories'); // false
     * helper.toggleFacetRefinement('categories', 'kitchen > knife');
     * helper.hasRefinements('categories'); // true
     *
     */
    hasRefinements(attribute: string): boolean;
    /**
     * Check if a value is excluded for a specific faceted attribute. If the value
     * is omitted then the function checks if there is any excluding refinements.
     *
     * @param  {string}  facet name of the attribute for used for faceting
     * @param  {string}  [value] optional value. If passed will test that this value
       * is filtering the given facet.
     * @return {boolean} true if refined
     * @example
     * helper.isExcludeRefined('color'); // false
     * helper.isExcludeRefined('color', 'blue') // false
     * helper.isExcludeRefined('color', 'red') // false
     *
     * helper.addFacetExclusion('color', 'red');
     *
     * helper.isExcludeRefined('color'); // true
     * helper.isExcludeRefined('color', 'blue') // false
     * helper.isExcludeRefined('color', 'red') // true
     */
    isExcluded(facet: string, value: string): boolean;
    /**
     * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasRefinements}
     */
    isDisjunctiveRefined(facet: string, value: string): boolean;
    /**
     * Check if the string is a currently filtering tag.
     * @param {string} tag tag to check
     * @return {boolean}
     */
    hasTag(tag: string): boolean;
    /**
     * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasTag}
     */
    isTagRefined(tag: string): boolean;
    /**
     * Get the name of the currently used index.
     * @return {string}
     * @example
     * helper.setIndex('highestPrice_products').getIndex();
     * // returns 'highestPrice_products'
     */
    getIndex(): string;
    /**
     * Get the currently selected page
     * @deprecated
     * @return {number} the current page
     */
    getCurrentPage(): number | undefined;
    /**
     * Get the currently selected page
     * @function
     * @return {number} the current page
     */
    getPage: () => number | undefined;
    /**
     * Get all the tags currently set to filters the results.
     *
     * @return {string[]} The list of tags currently set.
     */
    getTags(): string[];
    /**
     * Get the list of refinements for a given attribute. This method works with
     * conjunctive, disjunctive, excluding and numerical filters.
     *
     * See also SearchResults#getRefinements
     *
     * @param {string} facetName attribute name used for faceting
     * @return {Array.<FacetRefinement|NumericRefinement>} All Refinement are objects that contain a value, and
     * a type. Numeric also contains an operator.
     * @example
     * helper.addNumericRefinement('price', '>', 100);
     * helper.getRefinements('price');
     * // [
     * //   {
     * //     "value": [
     * //       100
     * //     ],
     * //     "operator": ">",
     * //     "type": "numeric"
     * //   }
     * // ]
     * @example
     * helper.addFacetRefinement('color', 'blue');
     * helper.addFacetExclusion('color', 'red');
     * helper.getRefinements('color');
     * // [
     * //   {
     * //     "value": "blue",
     * //     "type": "conjunctive"
     * //   },
     * //   {
     * //     "value": "red",
     * //     "type": "exclude"
     * //   }
     * // ]
     * @example
     * helper.addDisjunctiveFacetRefinement('material', 'plastic');
     * // [
     * //   {
     * //     "value": "plastic",
     * //     "type": "disjunctive"
     * //   }
     * // ]
     */
    getRefinements(facetName: string): any[];
    /**
     * Return the current refinement for the (attribute, operator)
     * @param {string} attribute attribute in the record
     * @param {string} operator operator applied on the refined values
     * @return {Array.<number|number[]>} refined values
     */
    getNumericRefinement(attribute: string, operator: Operator_2): (number | number[])[];
    /**
     * Get the current breadcrumb for a hierarchical facet, as an array
     * @param  {string} facetName Hierarchical facet name
     * @return {array.<string>} the path as an array of string
     */
    getHierarchicalFacetBreadcrumb(facetName: string): string[];
    /**
     * Perform the underlying queries
     * @private
     * @return {undefined}
     * @fires search
     * @fires result
     * @fires error
     */
    _search(options: {
        onlyWithDerivedHelpers: boolean;
    }): void;
    /**
     * Transform the responses as sent by the server and transform them into a user
     * usable object that merge the results of all the batch requests. It will dispatch
     * over the different helper + derived helpers (when there are some).
     * @private
     * @param {array.<{SearchParameters, AlgoliaQueries, AlgoliaSearchHelper}>}
     *  state state used for to generate the request
     * @param {number} queryId id of the current request
     * @param {object} content content of the response
     * @return {undefined}
     */
    _dispatchAlgoliaResponse(states: {
        state: SearchParameters;
        queriesCount: number;
        helper: AlgoliaSearchHelper | DerivedHelper;
    }[], queryId: number, content: MultipleQueriesResponse<any>): void;
    _dispatchAlgoliaError(queryId: number, error: Error): void;
    containsRefinement(query: string, facetFilters: string[], numericFilters: string[], tagFilters: string[]): string | boolean;
    /**
     * Test if there are some disjunctive refinements on the facet
     * @private
     * @param {string} facet the attribute to test
     * @return {boolean}
     */
    _hasDisjunctiveRefinements(facet: string): boolean | undefined;
    _change(event: {
        state: SearchParameters;
        isPageReset: boolean;
    }): void;
    /**
     * Clears the cache of the underlying Algolia client.
     * @return {AlgoliaSearchHelper}
     */
    clearCache(): this;
    /**
     * Updates the internal client instance. If the reference of the clients
     * are equal then no update is actually done.
     * @param  {AlgoliaSearch} newClient an AlgoliaSearch client
     * @return {AlgoliaSearchHelper}
     */
    setClient(newClient: SearchClient): this;
    /**
     * Gets the instance of the currently used client.
     * @return {AlgoliaSearch}
     */
    getClient(): SearchClient;
    /**
     * Creates an derived instance of the Helper. A derived helper
     * is a way to request other indices synchronised with the lifecycle
     * of the main Helper. This mechanism uses the multiqueries feature
     * of Algolia to aggregate all the requests in a single network call.
     *
     * This method takes a function that is used to create a new SearchParameter
     * that will be used to create requests to Algolia. Those new requests
     * are created just before the `search` event. The signature of the function
     * is `SearchParameters -> SearchParameters`.
     *
     * This method returns a new DerivedHelper which is an EventEmitter
     * that fires the same `search`, `result` and `error` events. Those
     * events, however, will receive data specific to this DerivedHelper
     * and the SearchParameters that is returned by the call of the
     * parameter function.
     * @param {function} fn SearchParameters -> SearchParameters
     * @return {DerivedHelper}
     */
    derive(fn: ((params: SearchParameters) => SearchParameters)): DerivedHelper;
    /**
     * This method detaches a derived Helper from the main one. Prefer using the one from the
     * derived helper itself, to remove the event listeners too.
     * @private
     * @return {undefined}
     * @throws Error
     */
    detachDerivedHelper(derivedHelper: DerivedHelper): void;
    /**
     * This method returns true if there is currently at least one on-going search.
     * @return {boolean} true if there is a search pending
     */
    hasPendingRequests(): boolean;
}

/**
 * The algoliasearchHelper module is the function that will let its
 * contains everything needed to use the Algoliasearch
 * Helper. It is a also a function that instanciate the helper.
 * To use the helper, you also need the Algolia JS client v3.
 * @example
 * //using the UMD build
 * var client = algoliasearch('latency', '6be0576ff61c053d5f9a3225e2a90f76');
 * var helper = algoliasearchHelper(client, 'bestbuy', {
 *   facets: ['shipping'],
 *   disjunctiveFacets: ['category']
 * });
 * helper.on('result', function(event) {
 *   console.log(event.results);
 * });
 * helper
 *   .toggleFacetRefinement('category', 'Movies & TV Shows')
 *   .toggleFacetRefinement('shipping', 'Free shipping')
 *   .search();
 * @example
 * // The helper is an event emitter using the node API
 * helper.on('result', updateTheResults);
 * helper.once('result', updateTheResults);
 * helper.removeListener('result', updateTheResults);
 * helper.removeAllListeners('result');
 * @module algoliasearchHelper
 * @param  {AlgoliaSearch} client an AlgoliaSearch client
 * @param  {string} index the name of the index to query
 * @param  {SearchParameters|object} opts an object defining the initial config of the search. It doesn't have to be a {SearchParameters}, just an object containing the properties you need from it.
 * @return {AlgoliaSearchHelper}
 */
declare function algoliasearchHelper(client: SearchClient, index: string, opts: SearchParameters): AlgoliaSearchHelper;

declare namespace algoliasearchHelper {
    var version: string;
    var AlgoliaSearchHelper: typeof import("./src/algoliasearch.helper").default;
    var SearchParameters: typeof import("./src/SearchParameters").default;
    var SearchResults: typeof import("./src/SearchResults").default;
}
export default algoliasearchHelper;

/**
 * A DerivedHelper is a way to create sub requests to
 * Algolia from a main helper.
 * @class
 * @classdesc The DerivedHelper provides an event based interface for search callbacks:
 *  - search: when a search is triggered using the `search()` method.
 *  - result: when the response is retrieved from Algolia and is processed.
 *    This event contains a {@link SearchResults} object and the
 *    {@link SearchParameters} corresponding to this answer.
 */
declare class DerivedHelper extends events.EventEmitter {
    main: AlgoliaSearchHelper;
    fn: ((params: SearchParameters) => SearchParameters);
    lastResults: SearchResults | null;
    constructor(mainHelper: AlgoliaSearchHelper, fn: ((params: SearchParameters) => SearchParameters));
    /**
     * Detach this helper from the main helper
     * @return {undefined}
     * @throws Error if the derived helper is already detached
     */
    detach(): void;
    getModifiedState(parameters: SearchParameters): SearchParameters;
}

declare type Facet = {
    name: string;
    stats?: {};
    data: any;
    exhaustive?: boolean;
};

declare type HierarchicalFacet = {
    name: string;
    attributes: string[];
    separator: string;
    rootPath?: string;
    sortBy: string[];
    showParentLevel: boolean;
};

declare var lib: {
    /**
     * Adds a refinement to a RefinementList
     * @param {RefinementList} refinementList the initial list
     * @param {string} attribute the attribute to refine
     * @param {string} value the value of the refinement, if the value is not a string it will be converted
     * @return {RefinementList} a new and updated refinement list
     */
    addRefinement: (refinementList: RefinementList, attribute: string, value: string) => any;
    /**
     * Removes refinement(s) for an attribute:
     *  - if the value is specified removes the refinement for the value on the attribute
     *  - if no value is specified removes all the refinements for this attribute
     * @param {RefinementList} refinementList the initial list
     * @param {string} attribute the attribute to refine
     * @param {string} [value] the value of the refinement
     * @return {RefinementList} a new and updated refinement lst
     */
    removeRefinement: (refinementList: RefinementList, attribute: string, value: string) => {
        [key: string]: any;
    };
    /**
     * Toggles the refinement value for an attribute.
     * @param {RefinementList} refinementList the initial list
     * @param {string} attribute the attribute to refine
     * @param {string} value the value of the refinement
     * @return {RefinementList} a new and updated list
     */
    toggleRefinement: (refinementList: RefinementList, attribute: string, value: string) => any;
    /**
     * Clear all or parts of a RefinementList. Depending on the arguments, three
     * kinds of behavior can happen:
     *  - if no attribute is provided: clears the whole list
     *  - if an attribute is provided as a string: clears the list for the specific attribute
     *  - if an attribute is provided as a function: discards the elements for which the function returns true
     * @param {RefinementList} refinementList the initial list
     * @param {string} [attribute] the attribute or function to discard
     * @param {string} [refinementType] optional parameter to give more context to the attribute function
     * @return {RefinementList} a new and updated refinement list
     */
    clearRefinement: (refinementList: RefinementList, attribute: string | ((value: any, key: string, refinementType?: string | undefined) => boolean), refinementType?: string | undefined) => {
        [key: string]: any;
    };
    /**
     * Test if the refinement value is used for the attribute. If no refinement value
     * is provided, test if the refinementList contains any refinement for the
     * given attribute.
     * @param {RefinementList} refinementList the list of refinement
     * @param {string} attribute name of the attribute
     * @param {string} [refinementValue] value of the filter/refinement
     * @return {boolean}
     */
    isRefined: (refinementList: RefinementList, attribute: string, refinementValue?: string | undefined) => boolean;
};

declare type MysteriousHierarchicalFacet = {
    name?: string;
    attribute?: string;
    data: any;
    exhaustive?: boolean;
    count?: number | null;
    path?: string | null;
    isRefined?: boolean;
};

declare type Operator = '=' | '>' | '>=' | '<' | '<=' | '!=';

declare type Operator_2 = '=' | '>' | '>=' | '<' | '<=' | '!=';

declare type OperatorList = {
    [k in Operator]: Array<number | number[]>;
};

declare type RefinementList = {
    [facet: string]: string[];
};

/**
 * The facet list is the structure used to store the list of values used to
 * filter a single attribute.
 * @typedef {string[]} SearchParameters.FacetList
 */
/**
 * Structure to store numeric filters with the operator as the key. The supported operators
 * are `=`, `>`, `<`, `>=`, `<=` and `!=`.
 * @typedef {Object.<string, Array.<number|number[]>>} SearchParameters.OperatorList
 */
/**
 * SearchParameters is the data structure that contains all the information
 * usable for making a search to Algolia API. It doesn't do the search itself,
 * nor does it contains logic about the parameters.
 * It is an immutable object, therefore it has been created in a way that each
 * changes does not change the object itself but returns a copy with the
 * modification.
 * This object should probably not be instantiated outside of the helper. It will
 * be provided when needed. This object is documented for reference as you'll
 * get it from events generated by the {@link AlgoliaSearchHelper}.
 * If need be, instantiate the Helper from the factory function {@link SearchParameters.make}
 * @constructor
 * @classdesc contains all the parameters of a search
 * @param {object|SearchParameters} newParameters existing parameters or partial object
 * for the properties of a new SearchParameters
 * @see SearchParameters.make
 * @example <caption>SearchParameters of the first query in
 *   <a href="http://demos.algolia.com/instant-search-demo/">the instant search demo</a></caption>
{
   "query": "",
   "disjunctiveFacets": [
      "customerReviewCount",
      "category",
      "salePrice_range",
      "manufacturer"
  ],
   "maxValuesPerFacet": 30,
   "page": 0,
   "hitsPerPage": 10,
   "facets": [
      "type",
      "shipping"
  ]
}
 */
declare class SearchParameters {
    facets: string[];
    disjunctiveFacets: string[];
    hierarchicalFacets: HierarchicalFacet[];
    facetsRefinements: lib;
    facetsExcludes: lib;
    disjunctiveFacetsRefinements: lib;
    numericRefinements: {
        [facet: string]: OperatorList;
    };
    tagRefinements: string[];
    hierarchicalFacetsRefinements: lib;
    tagFilters?: string[];
    index: string;
    query?: string;
    page?: number;
    hitsPerPage?: number;
    typoTolerance?: 'true' | 'false' | 'min' | 'strict';
    numericFilters?: string[];
    disjunctiveRefinements?: {
        [facet: string]: string[];
    };
    aroundPrecision?: number;
    aroundRadius?: number | 'all';
    getRankingInfo?: boolean;
    minWordSizefor2Typos?: number;
    minWordSizefor1Typo?: number;
    maxValuesPerFacet?: number;
    distinct?: number | boolean;
    minimumAroundRadius?: number;
    minProximity?: number;
    insideBoundingBox?: number[][];
    constructor(newParameters?: Partial<SearchParameters>);
    /**
     * List all the properties in SearchParameters and therefore all the known Algolia properties
     * This doesn't contain any beta/hidden features.
     * @private
     */
    static PARAMETERS: string[];
    /**
     * @private
     * @param {object} partialState full or part of a state
     * @return {object} a new object with the number keys as number
     */
    static _parseNumbers: (partialState: Partial<SearchParameters>) => Partial<SearchParameters>;
    /**
     * Factory for SearchParameters
     * @param {object|SearchParameters} newParameters existing parameters or partial
     * object for the properties of a new SearchParameters
     * @return {SearchParameters} frozen instance of SearchParameters
     */
    static make(newParameters: Partial<SearchParameters>): SearchParameters;
    /**
     * Validates the new parameters based on the previous state
     * @param {SearchParameters} currentState the current state
     * @param {object|SearchParameters} parameters the new parameters to set
     * @return {Error|null} Error if the modification is invalid, null otherwise
     */
    static validate: (currentState: SearchParameters, parameters: Partial<SearchParameters>) => Error | null;
    /**
     * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)
     * @method
     * @param {undefined|string|SearchParameters.clearCallback} [attribute] optional string or function
     * - If not given, means to clear all the filters.
     * - If `string`, means to clear all refinements for the `attribute` named filter.
     * - If `function`, means to clear all the refinements that return truthy values.
     * @return {SearchParameters}
     */
    clearRefinements(attribute: string | ((value: any, key: string, refinementType?: string | undefined) => boolean)): SearchParameters;
    /**
     * Remove all the refined tags from the SearchParameters
     * @method
     * @return {SearchParameters}
     */
    clearTags(): SearchParameters;
    /**
     * Set the index.
     * @method
     * @param {string} index the index name
     * @return {SearchParameters}
     */
    setIndex(index: string): SearchParameters;
    /**
     * Query setter
     * @method
     * @param {string} newQuery value for the new query
     * @return {SearchParameters}
     */
    setQuery(newQuery: string): SearchParameters;
    /**
     * Page setter
     * @method
     * @param {number} newPage new page number
     * @return {SearchParameters}
     */
    setPage(newPage: number): SearchParameters;
    /**
     * Facets setter
     * The facets are the simple facets, used for conjunctive (and) faceting.
     * @method
     * @param {string[]} facets all the attributes of the algolia records used for conjunctive faceting
     * @return {SearchParameters}
     */
    setFacets(facets: string[]): SearchParameters;
    /**
     * Disjunctive facets setter
     * Change the list of disjunctive (or) facets the helper chan handle.
     * @method
     * @param {string[]} facets all the attributes of the algolia records used for disjunctive faceting
     * @return {SearchParameters}
     */
    setDisjunctiveFacets(facets: string[]): SearchParameters;
    /**
     * HitsPerPage setter
     * Hits per page represents the number of hits retrieved for this query
     * @method
     * @param {number} n number of hits retrieved per page of results
     * @return {SearchParameters}
     */
    setHitsPerPage(n: number): SearchParameters;
    /**
     * typoTolerance setter
     * Set the value of typoTolerance
     * @method
     * @param {string} typoTolerance new value of typoTolerance ("true", "false", "min" or "strict")
     * @return {SearchParameters}
     */
    setTypoTolerance(typoTolerance: 'true' | 'false' | 'min' | 'strict'): SearchParameters;
    /**
     * Add a numeric filter for a given attribute
     * When value is an array, they are combined with OR
     * When value is a single value, it will combined with AND
     * @method
     * @param {string} attribute attribute to set the filter on
     * @param {string} operator operator of the filter (possible values: =, >, >=, <, <=, !=)
     * @param {number | number[]} value value of the filter
     * @return {SearchParameters}
     * @example
     * // for price = 50 or 40
     * searchparameter.addNumericRefinement('price', '=', [50, 40]);
     * @example
     * // for size = 38 and 40
     * searchparameter.addNumericRefinement('size', '=', 38);
     * searchparameter.addNumericRefinement('size', '=', 40);
     */
    addNumericRefinement(attribute: string, operator: Operator, v: number | number[]): SearchParameters;
    /**
     * Get the list of conjunctive refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getConjunctiveRefinements(facetName: string): string[];
    /**
     * Get the list of disjunctive refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getDisjunctiveRefinements(facetName: string): string[];
    /**
     * Get the list of hierarchical refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getHierarchicalRefinement(facetName: string): string[];
    /**
     * Get the list of exclude refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getExcludeRefinements(facetName: string): string[];
    /**
     * Remove all the numeric filter for a given (attribute, operator)
     * @method
     * @param {string} attribute attribute to set the filter on
     * @param {string} [operator] operator of the filter (possible values: =, >, >=, <, <=, !=)
     * @param {number} [number] the value to be removed
     * @return {SearchParameters}
     */
    removeNumericRefinement(attribute: string, operator: Operator, paramValue: number): SearchParameters;
    /**
     * Get the list of numeric refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {SearchParameters.OperatorList[]} list of refinements
     */
    getNumericRefinements(facetName: string): OperatorList;
    /**
     * Return the current refinement for the (attribute, operator)
     * @param {string} attribute attribute in the record
     * @param {string} operator operator applied on the refined values
     * @return {Array.<number|number[]>} refined values
     */
    getNumericRefinement(attribute: string, operator: Operator): (number | number[])[];
    /**
     * Clear numeric filters.
     * @method
     * @private
     * @param {string|SearchParameters.clearCallback} [attribute] optional string or function
     * - If not given, means to clear all the filters.
     * - If `string`, means to clear all refinements for the `attribute` named filter.
     * - If `function`, means to clear all the refinements that return truthy values.
     * @return {Object.<string, OperatorList>}
     */
    _clearNumericRefinements(attribute?: string | ((value: {
        val: any;
        op: Operator;
    }, key: string, attr: 'numeric') => boolean)): {
        [key: string]: any;
    };
    /**
     * Add a facet to the facets attribute of the helper configuration, if it
     * isn't already present.
     * @method
     * @param {string} facet facet name to add
     * @return {SearchParameters}
     */
    addFacet(facet: string): SearchParameters;
    /**
     * Add a disjunctive facet to the disjunctiveFacets attribute of the helper
     * configuration, if it isn't already present.
     * @method
     * @param {string} facet disjunctive facet name to add
     * @return {SearchParameters}
     */
    addDisjunctiveFacet(facet: string): SearchParameters;
    /**
     * Add a hierarchical facet to the hierarchicalFacets attribute of the helper
     * configuration.
     * @method
     * @param {object} hierarchicalFacet hierarchical facet to add
     * @return {SearchParameters}
     * @throws will throw an error if a hierarchical facet with the same name was already declared
     */
    addHierarchicalFacet(hierarchicalFacet: HierarchicalFacet): SearchParameters;
    /**
     * Add a refinement on a "normal" facet
     * @method
     * @param {string} facet attribute to apply the faceting on
     * @param {string} value value of the attribute (will be converted to string)
     * @return {SearchParameters}
     */
    addFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Exclude a value from a "normal" facet
     * @method
     * @param {string} facet attribute to apply the exclusion on
     * @param {string} value value of the attribute (will be converted to string)
     * @return {SearchParameters}
     */
    addExcludeRefinement(facet: string, value: string): SearchParameters;
    /**
     * Adds a refinement on a disjunctive facet.
     * @method
     * @param {string} facet attribute to apply the faceting on
     * @param {string} value value of the attribute (will be converted to string)
     * @return {SearchParameters}
     */
    addDisjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * addTagRefinement adds a tag to the list used to filter the results
     * @param {string} tag tag to be added
     * @return {SearchParameters}
     */
    addTagRefinement(tag: string): SearchParameters;
    /**
     * Remove a facet from the facets attribute of the helper configuration, if it
     * is present.
     * @method
     * @param {string} facet facet name to remove
     * @return {SearchParameters}
     */
    removeFacet(facet: string): SearchParameters;
    /**
     * Remove a disjunctive facet from the disjunctiveFacets attribute of the
     * helper configuration, if it is present.
     * @method
     * @param {string} facet disjunctive facet name to remove
     * @return {SearchParameters}
     */
    removeDisjunctiveFacet(facet: string): SearchParameters;
    /**
     * Remove a hierarchical facet from the hierarchicalFacets attribute of the
     * helper configuration, if it is present.
     * @method
     * @param {string} facet hierarchical facet name to remove
     * @return {SearchParameters}
     */
    removeHierarchicalFacet(facet: string): SearchParameters;
    /**
     * Remove a refinement set on facet. If a value is provided, it will clear the
     * refinement for the given value, otherwise it will clear all the refinement
     * values for the faceted attribute.
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {string} [value] value used to filter
     * @return {SearchParameters}
     */
    removeFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Remove a negative refinement on a facet
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {string} value value used to filter
     * @return {SearchParameters}
     */
    removeExcludeRefinement(facet: string, value: string): SearchParameters;
    /**
     * Remove a refinement on a disjunctive facet
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {string} value value used to filter
     * @return {SearchParameters}
     */
    removeDisjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Remove a tag from the list of tag refinements
     * @method
     * @param {string} tag the tag to remove
     * @return {SearchParameters}
     */
    removeTagRefinement(tag: string): SearchParameters;
    /**
     * Generic toggle refinement method to use with facet, disjunctive facets
     * and hierarchical facets
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {SearchParameters}
     * @throws will throw an error if the facet is not declared in the settings of the helper
     * @deprecated since version 2.19.0, see {@link SearchParameters#toggleFacetRefinement}
     */
    toggleRefinement(facet: string, value: string): SearchParameters;
    /**
     * Generic toggle refinement method to use with facet, disjunctive facets
     * and hierarchical facets
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {SearchParameters}
     * @throws will throw an error if the facet is not declared in the settings of the helper
     */
    toggleFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleConjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleExcludeFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleDisjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleHierarchicalFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Adds a refinement on a hierarchical facet.
     * @param {string} facet the facet name
     * @param {string} path the hierarchical facet path
     * @return {SearchParameter} the new state
     * @throws Error if the facet is not defined or if the facet is refined
     */
    addHierarchicalFacetRefinement(facet: string, path: string): SearchParameters;
    /**
     * Removes the refinement set on a hierarchical facet.
     * @param {string} facet the facet name
     * @return {SearchParameter} the new state
     * @throws Error if the facet is not defined or if the facet is not refined
     */
    removeHierarchicalFacetRefinement(facet: string): SearchParameters;
    /**
     * Switch the tag refinement
     * @method
     * @param {string} tag the tag to remove or add
     * @return {SearchParameters}
     */
    toggleTagRefinement(tag: string): SearchParameters;
    /**
     * Test if the facet name is from one of the disjunctive facets
     * @method
     * @param {string} facet facet name to test
     * @return {boolean}
     */
    isDisjunctiveFacet(facet: string): boolean;
    /**
     * Test if the facet name is from one of the hierarchical facets
     * @method
     * @param {string} facetName facet name to test
     * @return {boolean}
     */
    isHierarchicalFacet(facetName: string): boolean;
    /**
     * Test if the facet name is from one of the conjunctive/normal facets
     * @method
     * @param {string} facet facet name to test
     * @return {boolean}
     */
    isConjunctiveFacet(facet: string): boolean;
    /**
     * Returns true if the facet is refined, either for a specific value or in
     * general.
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} value, optional value. If passed will test that this value
     * is filtering the given facet.
     * @return {boolean} returns true if refined
     */
    isFacetRefined(facet: string, value?: string): boolean;
    /**
     * Returns true if the facet contains exclusions or if a specific value is
     * excluded.
     *
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} [value] optional value. If passed will test that this value
     * is filtering the given facet.
     * @return {boolean} returns true if refined
     */
    isExcludeRefined(facet: string, value: string): boolean;
    /**
     * Returns true if the facet contains a refinement, or if a value passed is a
     * refinement for the facet.
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} value optional, will test if the value is used for refinement
     * if there is one, otherwise will test if the facet contains any refinement
     * @return {boolean}
     */
    isDisjunctiveFacetRefined(facet: string, value?: string): boolean;
    /**
     * Returns true if the facet contains a refinement, or if a value passed is a
     * refinement for the facet.
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} value optional, will test if the value is used for refinement
     * if there is one, otherwise will test if the facet contains any refinement
     * @return {boolean}
     */
    isHierarchicalFacetRefined(facet: string, value?: string): boolean;
    /**
     * Test if the triple (attribute, operator, value) is already refined.
     * If only the attribute and the operator are provided, it tests if the
     * contains any refinement value.
     * @method
     * @param {string} attribute attribute for which the refinement is applied
     * @param {string} [operator] operator of the refinement
     * @param {string} [value] value of the refinement
     * @return {boolean} true if it is refined
     */
    isNumericRefined(attribute: string, operator?: Operator, value?: number | number[]): boolean;
    /**
     * Returns true if the tag refined, false otherwise
     * @method
     * @param {string} tag the tag to check
     * @return {boolean}
     */
    isTagRefined(tag: string): boolean;
    /**
     * Returns the list of all disjunctive facets refined
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {string[]}
     */
    getRefinedDisjunctiveFacets(): string[];
    /**
     * Returns the list of all disjunctive facets refined
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {string[]}
     */
    getRefinedHierarchicalFacets(): string[];
    /**
     * Returned the list of all disjunctive facets not refined
     * @method
     * @return {string[]}
     */
    getUnrefinedDisjunctiveFacets(): string[];
    managedParameters: string[];
    getQueryParams(): {
        facets?: any;
        disjunctiveFacets?: any;
        hierarchicalFacets?: any;
        facetsRefinements?: any;
        facetsExcludes?: any;
        disjunctiveFacetsRefinements?: any;
        numericRefinements?: any;
        tagRefinements?: any;
        hierarchicalFacetsRefinements?: any;
        tagFilters?: any;
        index?: any;
        query?: any;
        page?: any;
        hitsPerPage?: any;
        typoTolerance?: any;
        numericFilters?: any;
        disjunctiveRefinements?: any;
        aroundPrecision?: any;
        aroundRadius?: any;
        getRankingInfo?: any;
        minWordSizefor2Typos?: any;
        minWordSizefor1Typo?: any;
        maxValuesPerFacet?: any;
        distinct?: any;
        minimumAroundRadius?: any;
        minProximity?: any;
        insideBoundingBox?: any;
        clearRefinements?: any;
        clearTags?: any;
        setIndex?: any;
        setQuery?: any;
        setPage?: any;
        setFacets?: any;
        setDisjunctiveFacets?: any;
        setHitsPerPage?: any;
        setTypoTolerance?: any;
        addNumericRefinement?: any;
        getConjunctiveRefinements?: any;
        getDisjunctiveRefinements?: any;
        getHierarchicalRefinement?: any;
        getExcludeRefinements?: any;
        removeNumericRefinement?: any;
        getNumericRefinements?: any;
        getNumericRefinement?: any;
        _clearNumericRefinements?: any;
        addFacet?: any;
        addDisjunctiveFacet?: any;
        addHierarchicalFacet?: any;
        addFacetRefinement?: any;
        addExcludeRefinement?: any;
        addDisjunctiveFacetRefinement?: any;
        addTagRefinement?: any;
        removeFacet?: any;
        removeDisjunctiveFacet?: any;
        removeHierarchicalFacet?: any;
        removeFacetRefinement?: any;
        removeExcludeRefinement?: any;
        removeDisjunctiveFacetRefinement?: any;
        removeTagRefinement?: any;
        toggleRefinement?: any;
        toggleFacetRefinement?: any;
        toggleConjunctiveFacetRefinement?: any;
        toggleExcludeFacetRefinement?: any;
        toggleDisjunctiveFacetRefinement?: any;
        toggleHierarchicalFacetRefinement?: any;
        addHierarchicalFacetRefinement?: any;
        removeHierarchicalFacetRefinement?: any;
        toggleTagRefinement?: any;
        isDisjunctiveFacet?: any;
        isHierarchicalFacet?: any;
        isConjunctiveFacet?: any;
        isFacetRefined?: any;
        isExcludeRefined?: any;
        isDisjunctiveFacetRefined?: any;
        isHierarchicalFacetRefined?: any;
        isNumericRefined?: any;
        isTagRefined?: any;
        getRefinedDisjunctiveFacets?: any;
        getRefinedHierarchicalFacets?: any;
        getUnrefinedDisjunctiveFacets?: any;
        managedParameters?: any;
        getQueryParams?: any;
        setQueryParameter?: any;
        setQueryParameters?: any;
        resetPage?: any;
        _getHierarchicalFacetSortBy?: any;
        _getHierarchicalFacetSeparator?: any;
        _getHierarchicalRootPath?: any;
        _getHierarchicalShowParentLevel?: any;
        getHierarchicalFacetByName?: any;
        getHierarchicalFacetBreadcrumb?: any;
        toString?: any;
    };
    /**
     * Let the user set a specific value for a given parameter. Will return the
     * same instance if the parameter is invalid or if the value is the same as the
     * previous one.
     * @method
     * @param {string} parameter the parameter name
     * @param {any} value the value to be set, must be compliant with the definition
     * of the attribute on the object
     * @return {SearchParameters} the updated state
     */
    setQueryParameter(parameter: keyof SearchParameters, value: ValueOf<SearchParameters>): SearchParameters;
    /**
     * Let the user set any of the parameters with a plain object.
     * @method
     * @param {object} params all the keys and the values to be updated
     * @return {SearchParameters} a new updated instance
     */
    setQueryParameters(params: Partial<SearchParameters>): SearchParameters;
    /**
     * Returns a new instance with the page reset. Two scenarios possible:
     * the page is omitted -> return the given instance
     * the page is set -> return a new instance with a page of 0
     * @return {SearchParameters} a new updated instance
     */
    resetPage(): SearchParameters;
    /**
     * Helper function to get the hierarchicalFacet separator or the default one (`>`)
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.separator or `>` as default
     */
    _getHierarchicalFacetSortBy(hierarchicalFacet: HierarchicalFacet): string[];
    /**
     * Helper function to get the hierarchicalFacet separator or the default one (`>`)
     * @private
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.separator or `>` as default
     */
    _getHierarchicalFacetSeparator(hierarchicalFacet?: HierarchicalFacet): string;
    /**
     * Helper function to get the hierarchicalFacet prefix path or null
     * @private
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.rootPath or null as default
     */
    _getHierarchicalRootPath(hierarchicalFacet?: HierarchicalFacet): string | null;
    /**
     * Helper function to check if we show the parent level of the hierarchicalFacet
     * @private
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.showParentLevel or true as default
     */
    _getHierarchicalShowParentLevel(hierarchicalFacet: HierarchicalFacet): boolean;
    /**
     * Helper function to get the hierarchicalFacet by it's name
     * @param  {string} hierarchicalFacetName
     * @return {object} a hierarchicalFacet
     */
    getHierarchicalFacetByName(hierarchicalFacetName: string): HierarchicalFacet | undefined;
    /**
     * Get the current breadcrumb for a hierarchical facet, as an array
     * @param  {string} facetName Hierarchical facet name
     * @return {array.<string>} the path as an array of string
     */
    getHierarchicalFacetBreadcrumb(facetName: string): string[];
    toString(): string;
}

/**
 * Constructor for SearchResults
 * @class
 * @classdesc SearchResults contains the results of a query to Algolia using the
 * {@link AlgoliaSearchHelper}.
 * @param {SearchParameters} state state that led to the response
 * @param {array.<object>} results the results from algolia client
 * @example <caption>SearchResults of the first query in
 * <a href="http://demos.algolia.com/instant-search-demo">the instant search demo</a></caption>
{
   "hitsPerPage": 10,
   "processingTimeMS": 2,
   "facets": [
      {
         "name": "type",
         "data": {
            "HardGood": 6627,
            "BlackTie": 550,
            "Music": 665,
            "Software": 131,
            "Game": 456,
            "Movie": 1571
         },
         "exhaustive": false
      },
      {
         "exhaustive": false,
         "data": {
            "Free shipping": 5507
         },
         "name": "shipping"
      }
  ],
   "hits": [
      {
         "thumbnailImage": "http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_54x108_s.gif",
         "_highlightResult": {
            "shortDescription": {
               "matchLevel": "none",
               "value": "Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection",
               "matchedWords": []
            },
            "category": {
               "matchLevel": "none",
               "value": "Computer Security Software",
               "matchedWords": []
            },
            "manufacturer": {
               "matchedWords": [],
               "value": "Webroot",
               "matchLevel": "none"
            },
            "name": {
               "value": "Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows",
               "matchedWords": [],
               "matchLevel": "none"
            }
         },
         "image": "http://img.bbystatic.com/BestBuy_US/images/products/1688/1688832_105x210_sc.jpg",
         "shipping": "Free shipping",
         "bestSellingRank": 4,
         "shortDescription": "Safeguard your PC, Mac, Android and iOS devices with comprehensive Internet protection",
         "url": "http://www.bestbuy.com/site/webroot-secureanywhere-internet-security-3-devi…d=1219060687969&skuId=1688832&cmp=RMX&ky=2d3GfEmNIzjA0vkzveHdZEBgpPCyMnLTJ",
         "name": "Webroot SecureAnywhere Internet Security (3-Device) (1-Year Subscription) - Mac/Windows",
         "category": "Computer Security Software",
         "salePrice_range": "1 - 50",
         "objectID": "1688832",
         "type": "Software",
         "customerReviewCount": 5980,
         "salePrice": 49.99,
         "manufacturer": "Webroot"
      },
      ....
  ],
   "nbHits": 10000,
   "disjunctiveFacets": [
      {
         "exhaustive": false,
         "data": {
            "5": 183,
            "12": 112,
            "7": 149,
            ...
         },
         "name": "customerReviewCount",
         "stats": {
            "max": 7461,
            "avg": 157.939,
            "min": 1
         }
      },
      {
         "data": {
            "Printer Ink": 142,
            "Wireless Speakers": 60,
            "Point & Shoot Cameras": 48,
            ...
         },
         "name": "category",
         "exhaustive": false
      },
      {
         "exhaustive": false,
         "data": {
            "> 5000": 2,
            "1 - 50": 6524,
            "501 - 2000": 566,
            "201 - 500": 1501,
            "101 - 200": 1360,
            "2001 - 5000": 47
         },
         "name": "salePrice_range"
      },
      {
         "data": {
            "Dynex™": 202,
            "Insignia™": 230,
            "PNY": 72,
            ...
         },
         "name": "manufacturer",
         "exhaustive": false
      }
  ],
   "query": "",
   "nbPages": 100,
   "page": 0,
   "index": "bestbuy"
}
 **/
declare class SearchResults {
    _rawResults: readonly SearchResponse<any>[];
    query: string;
    parsedQuery?: string;
    hits: readonly any[];
    index?: string;
    hitsPerPage: number;
    nbHits: number;
    nbPages: number;
    page: number;
    processingTimeMS: number;
    aroundLatLng?: string;
    automaticRadius?: string;
    serverUsed?: string;
    exhaustiveFacetsCount?: boolean;
    exhaustiveNbHits: boolean;
    userData?: any;
    queryID?: string;
    disjunctiveFacets: Facet[];
    hierarchicalFacets: MysteriousHierarchicalFacet[];
    facets: Facet[];
    _state: SearchParameters;
    constructor(state: SearchParameters, results: readonly SearchResponse<any>[]);
    /**
     * Get a facet object with its name
     * @deprecated
     * @param {string} name name of the faceted attribute
     * @return {SearchResults.Facet} the facet object
     */
    getFacetByName(name: string): Facet | MysteriousHierarchicalFacet | undefined;
    static DEFAULT_SORT: string[];
    /**
     * Get a the list of values for a given facet attribute. Those values are sorted
     * refinement first, descending count (bigger value on top), and name ascending
     * (alphabetical order). The sort formula can overridden using either string based
     * predicates or a function.
     *
     * This method will return all the values returned by the Algolia engine plus all
     * the values already refined. This means that it can happen that the
     * `maxValuesPerFacet` [configuration](https://www.algolia.com/doc/rest-api/search#param-maxValuesPerFacet)
     * might not be respected if you have facet values that are already refined.
     * @param {string} attribute attribute name
     * @param {object} opts configuration options.
     * @param {Array.<string> | function} opts.sortBy
     * When using strings, it consists of
     * the name of the [FacetValue](#SearchResults.FacetValue) or the
     * [HierarchicalFacet](#SearchResults.HierarchicalFacet) attributes with the
     * order (`asc` or `desc`). For example to order the value by count, the
     * argument would be `['count:asc']`.
     *
     * If only the attribute name is specified, the ordering defaults to the one
     * specified in the default value for this attribute.
     *
     * When not specified, the order is
     * ascending.  This parameter can also be a function which takes two facet
     * values and should return a number, 0 if equal, 1 if the first argument is
     * bigger or -1 otherwise.
     *
     * The default value for this attribute `['isRefined:desc', 'count:desc', 'name:asc']`
     * @return {FacetValue[]|HierarchicalFacet|undefined} depending on the type of facet of
     * the attribute requested (hierarchical, disjunctive or conjunctive)
     * @example
     * helper.on('result', function(event){
     *   //get values ordered only by name ascending using the string predicate
     *   event.results.getFacetValues('city', {sortBy: ['name:asc']});
     *   //get values  ordered only by count ascending using a function
     *   event.results.getFacetValues('city', {
     *     // this is equivalent to ['count:asc']
     *     sortBy: function(a, b) {
     *       if (a.count === b.count) return 0;
     *       if (a.count > b.count)   return 1;
     *       if (b.count > a.count)   return -1;
     *     }
     *   });
     * });
     */
    getFacetValues(attribute: string, opts?: {
        sortBy: string[];
    }): any;
    /**
     * Returns the facet stats if attribute is defined and the facet contains some.
     * Otherwise returns undefined.
     * @param {string} attribute name of the faceted attribute
     * @return {object} The stats of the facet
     */
    getFacetStats(attribute: string): {} | undefined;
    /**
     * Returns all refinements for all filters + tags. It also provides
     * additional information: count and exhaustiveness for each filter.
     *
     * See the [refinement type](#Refinement) for an exhaustive view of the available
     * data.
     *
     * Note that for a numeric refinement, results are grouped per operator, this
     * means that it will return responses for operators which are empty.
     *
     * @return {Array.<Refinement>} all the refinements
     */
    getRefinements(): {
        type: any;
        attributeName: string;
        name: any;
        count?: any;
        exhaustive?: any;
        numericValue?: any;
        operator?: string | undefined;
    }[];
}

declare type ValueOf<T> = T[keyof T];

export { }
