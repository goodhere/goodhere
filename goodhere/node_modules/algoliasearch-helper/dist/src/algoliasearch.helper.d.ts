/// <reference types="node" />
import SearchParameters from './SearchParameters';
import SearchResults from './SearchResults';
import DerivedHelper from './DerivedHelper';
import events from 'events';
import { SearchClient } from 'algoliasearch';
import { SearchForFacetValuesResponse, MultipleQueriesResponse } from '@algolia/client-search';
declare type Operator = '=' | '>' | '>=' | '<' | '<=' | '!=';
/**
 * Event triggered when a parameter is set or updated
 * @event AlgoliaSearchHelper#event:change
 * @property {object} event
 * @property {SearchParameters} event.state the current parameters with the latest changes applied
 * @property {SearchResults} event.results the previous results received from Algolia. `null` before the first request
 * @example
 * helper.on('change', function(event) {
 *   console.log('The parameters have changed');
 * });
 */
/**
 * Event triggered when a main search is sent to Algolia
 * @event AlgoliaSearchHelper#event:search
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search
 * @property {SearchResults} event.results the results from the previous search. `null` if it is the first search.
 * @example
 * helper.on('search', function(event) {
 *   console.log('Search sent');
 * });
 */
/**
 * Event triggered when a search using `searchForFacetValues` is sent to Algolia
 * @event AlgoliaSearchHelper#event:searchForFacetValues
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search it is the first search.
 * @property {string} event.facet the facet searched into
 * @property {string} event.query the query used to search in the facets
 * @example
 * helper.on('searchForFacetValues', function(event) {
 *   console.log('searchForFacetValues sent');
 * });
 */
/**
 * Event triggered when a search using `searchOnce` is sent to Algolia
 * @event AlgoliaSearchHelper#event:searchOnce
 * @property {object} event
 * @property {SearchParameters} event.state the parameters used for this search it is the first search.
 * @example
 * helper.on('searchOnce', function(event) {
 *   console.log('searchOnce sent');
 * });
 */
/**
 * Event triggered when the results are retrieved from Algolia
 * @event AlgoliaSearchHelper#event:result
 * @property {object} event
 * @property {SearchResults} event.results the results received from Algolia
 * @property {SearchParameters} event.state the parameters used to query Algolia. Those might be different from the one in the helper instance (for example if the network is unreliable).
 * @example
 * helper.on('result', function(event) {
 *   console.log('Search results received');
 * });
 */
/**
 * Event triggered when Algolia sends back an error. For example, if an unknown parameter is
 * used, the error can be caught using this event.
 * @event AlgoliaSearchHelper#event:error
 * @property {object} event
 * @property {Error} event.error the error returned by the Algolia.
 * @example
 * helper.on('error', function(event) {
 *   console.log('Houston we got a problem.');
 * });
 */
/**
 * Event triggered when the queue of queries have been depleted (with any result or outdated queries)
 * @event AlgoliaSearchHelper#event:searchQueueEmpty
 * @example
 * helper.on('searchQueueEmpty', function() {
 *   console.log('No more search pending');
 *   // This is received before the result event if we're not expecting new results
 * });
 *
 * helper.search();
 */
/**
 * Initialize a new AlgoliaSearchHelper
 * @class
 * @classdesc The AlgoliaSearchHelper is a class that ease the management of the
 * search. It provides an event based interface for search callbacks:
 *  - change: when the internal search state is changed.
 *    This event contains a {@link SearchParameters} object and the
 *    {@link SearchResults} of the last result if any.
 *  - search: when a search is triggered using the `search()` method.
 *  - result: when the response is retrieved from Algolia and is processed.
 *    This event contains a {@link SearchResults} object and the
 *    {@link SearchParameters} corresponding to this answer.
 *  - error: when the response is an error. This event contains the error returned by the server.
 * @param  {AlgoliaSearch} client an AlgoliaSearch client
 * @param  {string} index the index name to query
 * @param  {SearchParameters | object} options an object defining the initial
 * config of the search. It doesn't have to be a {SearchParameters},
 * just an object containing the properties you need from it.
 */
declare class AlgoliaSearchHelper extends events.EventEmitter {
    state: SearchParameters;
    lastResults: SearchResults | null;
    derivedHelpers: DerivedHelper[];
    client: SearchClient;
    _queryId: number;
    _lastQueryIdReceived: number;
    _currentNbQueries: number;
    constructor(client: SearchClient, index: string, options: SearchParameters);
    /**
     * Start the search with the parameters set in the state. When the
     * method is called, it triggers a `search` event. The results will
     * be available through the `result` event. If an error occurs, an
     * `error` will be fired instead.
     * @return {AlgoliaSearchHelper}
     * @fires search
     * @fires result
     * @fires error
     * @chainable
     */
    search(): this;
    searchOnlyWithDerivedHelpers(): this;
    /**
     * Gets the search query parameters that would be sent to the Algolia Client
     * for the hits
     * @return {object} Query Parameters
     */
    getQuery(): any;
    /**
     * Start a search using a modified version of the current state. This method does
     * not trigger the helper lifecycle and does not modify the state kept internally
     * by the helper. This second aspect means that the next search call will be the
     * same as a search call before calling searchOnce.
     * @param {object} options can contain all the parameters that can be set to SearchParameters
     * plus the index
     * @param {function} [callback] optional callback executed when the response from the
     * server is back.
     * @return {promise|undefined} if a callback is passed the method returns undefined
     * otherwise it returns a promise containing an object with two keys :
     *  - content with a SearchResults
     *  - state with the state used for the query as a SearchParameters
     * @example
     * // Changing the number of records returned per page to 1
     * // This example uses the callback API
     * var state = helper.searchOnce({hitsPerPage: 1},
     *   function(error, content, state) {
     *     // if an error occurred it will be passed in error, otherwise its value is null
     *     // content contains the results formatted as a SearchResults
     *     // state is the instance of SearchParameters used for this search
     *   });
     * @example
     * // Changing the number of records returned per page to 1
     * // This example uses the promise API
     * var state1 = helper.searchOnce({hitsPerPage: 1})
     *                 .then(promiseHandler);
     *
     * function promiseHandler(res) {
     *   // res contains
     *   // {
     *   //   content : SearchResults
     *   //   state   : SearchParameters (the one used for this specific search)
     *   // }
     * }
     */
    searchOnce(options: SearchParameters): Promise<{
        content: SearchResults;
        state: SearchParameters;
    }>;
    searchOnce(options: SearchParameters, cb: (error: Error | null, content: SearchResults | null, state: SearchParameters) => void): void;
    /**
     * Structure of each result when using
     * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)
     * @typedef FacetSearchHit
     * @type {object}
     * @property {string} value the facet value
     * @property {string} highlighted the facet value highlighted with the query string
     * @property {number} count number of occurrence of this facet value
     * @property {boolean} isRefined true if the value is already refined
     */
    /**
     * Structure of the data resolved by the
     * [`searchForFacetValues()`](reference.html#AlgoliaSearchHelper#searchForFacetValues)
     * promise.
     * @typedef FacetSearchResult
     * @type {object}
     * @property {FacetSearchHit} facetHits the results for this search for facet values
     * @property {number} processingTimeMS time taken by the query inside the engine
     */
    /**
     * Search for facet values based on an query and the name of a faceted attribute. This
     * triggers a search and will return a promise. On top of using the query, it also sends
     * the parameters from the state so that the search is narrowed down to only the possible values.
     *
     * See the description of [FacetSearchResult](reference.html#FacetSearchResult)
     * @param {string} facet the name of the faceted attribute
     * @param {string} query the string query for the search
     * @param {number} [maxFacetHits] the maximum number values returned. Should be > 0 and <= 100
     * @param {object} [userState] the set of custom parameters to use on top of the current state. Setting a property to `undefined` removes
     * it in the generated query.
     * @return {promise.<FacetSearchResult>} the results of the search
     */
    searchForFacetValues(facet: string, query: string, maxFacetHits: number, userState: Partial<SearchParameters>): Promise<SearchForFacetValuesResponse>;
    /**
     * Sets the text query used for the search.
     *
     * This method resets the current page to 0.
     * @param  {string} q the user query
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setQuery(q: string): this;
    /**
     * Remove all the types of refinements except tags. A string can be provided to remove
     * only the refinements of a specific attribute. For more advanced use case, you can
     * provide a function instead. This function should follow the
     * [clearCallback definition](#SearchParameters.clearCallback).
     *
     * This method resets the current page to 0.
     * @param {string} [name] optional name of the facet / attribute on which we want to remove all refinements
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     * @example
     * // Removing all the refinements
     * helper.clearRefinements().search();
     * @example
     * // Removing all the filters on a the category attribute.
     * helper.clearRefinements('category').search();
     * @example
     * // Removing only the exclude filters on the category facet.
     * helper.clearRefinements(function(value, attribute, type) {
     *   return type === 'exclude' && attribute === 'category';
     * }).search();
     */
    clearRefinements(name: string): this;
    /**
     * Remove all the tag filters.
     *
     * This method resets the current page to 0.
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    clearTags(): this;
    /**
     * Adds a disjunctive filter to a faceted attribute with the `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value (will be converted to string)
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addDisjunctiveFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addDisjunctiveFacetRefinement}
     */
    addDisjunctiveRefine(facet: string, value: string): this;
    /**
     * Adds a refinement on a hierarchical facet. It will throwarguments
     * an exception if the facet is not defined or if the facet
     * is already refined.
     *
     * This method resets the current page to 0.
     * @param {string} facet the facet name
     * @param {string} path the hierarchical facet path
     * @return {AlgoliaSearchHelper}
     * @throws Error if the facet is not defined or if the facet is refined
     * @chainable
     * @fires change
     */
    addHierarchicalFacetRefinement(facet: string, value: string): this;
    /**
     * Adds a an numeric filter to an attribute with the `operator` and `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} attribute the attribute on which the numeric filter applies
     * @param  {string} operator the operator of the filter
     * @param  {number} value the value of the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addNumericRefinement(attribute: string, operator: Operator, value: number): this;
    /**
     * Adds a filter to a faceted attribute with the `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value (will be converted to string)
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetRefinement}
     */
    addRefine(facet: string, value: string): this;
    /**
     * Adds a an exclusion filter to a faceted attribute with the `value` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value (will be converted to string)
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addFacetExclusion(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#addFacetExclusion}
     */
    addExclude(facet: string, value: string): this;
    /**
     * Adds a tag filter with the `tag` provided. If the
     * filter is already set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param {string} tag the tag to add to the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    addTag(tag: string): this;
    /**
     * Removes an numeric filter to an attribute with the `operator` and `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * Some parameters are optional, triggering different behavior:
     *  - if the value is not provided, then all the numeric value will be removed for the
     *  specified attribute/operator couple.
     *  - if the operator is not provided either, then all the numeric filter on this attribute
     *  will be removed.
     *
     * This method resets the current page to 0.
     * @param  {string} attribute the attribute on which the numeric filter applies
     * @param  {string} [operator] the operator of the filter
     * @param  {number} [value] the value of the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeNumericRefinement(attribute: string, operator: Operator, value: number): this;
    /**
     * Removes a disjunctive filter to a faceted attribute with the `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * If the value is omitted, then this method will remove all the filters for the
     * attribute.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} [value] the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeDisjunctiveFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeDisjunctiveFacetRefinement}
     */
    removeDisjunctiveRefine(facet: string, value: string): this;
    /**
     * Removes the refinement set on a hierarchical facet.
     * @param {string} facet the facet name
     * @return {AlgoliaSearchHelper}
     * @throws Error if the facet is not defined or if the facet is not refined
     * @fires change
     * @chainable
     */
    removeHierarchicalFacetRefinement(facet: string): this;
    /**
     * Removes a filter to a faceted attribute with the `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * If the value is omitted, then this method will remove all the filters for the
     * attribute.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} [value] the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetRefinement}
     */
    removeRefine(facet: string, value: string): this;
    /**
     * Removes an exclusion filter to a faceted attribute with the `value` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * If the value is omitted, then this method will remove all the filters for the
     * attribute.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} [value] the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeFacetExclusion(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#removeFacetExclusion}
     */
    removeExclude(facet: string, value: string): this;
    /**
     * Removes a tag filter with the `tag` provided. If the
     * filter is not set, it doesn't change the filters.
     *
     * This method resets the current page to 0.
     * @param {string} tag tag to remove from the filter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    removeTag(tag: string): this;
    /**
     * Adds or removes an exclusion filter to a faceted attribute with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    toggleFacetExclusion(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetExclusion}
     */
    toggleExclude(facet: string, value: string): this;
    /**
     * Adds or removes a filter to a faceted attribute with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method can be used for conjunctive, disjunctive and hierarchical filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     * @throws Error will throw an error if the facet is not declared in the settings of the helper
     * @fires change
     * @chainable
     * @deprecated since version 2.19.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}
     */
    toggleRefinement(facet: string, value: string): this;
    /**
     * Adds or removes a filter to a faceted attribute with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method can be used for conjunctive, disjunctive and hierarchical filters.
     *
     * This method resets the current page to 0.
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {AlgoliaSearchHelper}
     * @throws Error will throw an error if the facet is not declared in the settings of the helper
     * @fires change
     * @chainable
     */
    toggleFacetRefinement(facet: string, value: string): this;
    /**
     * @deprecated since version 2.4.0, see {@link AlgoliaSearchHelper#toggleFacetRefinement}
     */
    toggleRefine(facet: string, value: string): this;
    /**
     * Adds or removes a tag filter with the `value` provided. If
     * the value is set then it removes it, otherwise it adds the filter.
     *
     * This method resets the current page to 0.
     * @param {string} tag tag to remove or add
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    toggleTag(tag: string): this;
    /**
     * Increments the page number by one.
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     * @example
     * helper.setPage(0).nextPage().getPage();
     * // returns 1
     */
    nextPage(): this;
    /**
     * Decrements the page number by one.
     * @fires change
     * @return {AlgoliaSearchHelper}
     * @chainable
     * @example
     * helper.setPage(1).previousPage().getPage();
     * // returns 0
     */
    previousPage(): this;
    /**
     * Change the current page
     * @deprecated
     * @param  {number} page The page number
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setCurrentPage(page: number): this;
    /**
     * Updates the current page.
     * @function
     * @param  {number} page The page number
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setPage: (page: number) => this;
    /**
     * Updates the name of the index that will be targeted by the query.
     *
     * This method resets the current page to 0.
     * @param {string} name the index name
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setIndex(name: string): this;
    /**
     * Update a parameter of the search. This method reset the page
     *
     * The complete list of parameters is available on the
     * [Algolia website](https://www.algolia.com/doc/rest#query-an-index).
     * The most commonly used parameters have their own [shortcuts](#query-parameters-shortcuts)
     * or benefit from higher-level APIs (all the kind of filters and facets have their own API)
     *
     * This method resets the current page to 0.
     * @param {string} parameter name of the parameter to update
     * @param {any} value new value of the parameter
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     * @example
     * helper.setQueryParameter('hitsPerPage', 20).search();
     */
    setQueryParameter(parameter: keyof SearchParameters, value: any): this;
    /**
     * Set the whole state (warning: will erase previous state)
     * @param {SearchParameters} newState the whole new state
     * @return {AlgoliaSearchHelper}
     * @fires change
     * @chainable
     */
    setState(newState: Partial<SearchParameters>): this;
    /**
     * Override the current state without triggering a change event.
     * Do not use this method unless you know what you are doing. (see the example
     * for a legit use case)
     * @param {SearchParameters} newState the whole new state
     * @return {AlgoliaSearchHelper}
     * @example
     *  helper.on('change', function(state){
     *    // In this function you might want to find a way to store the state in the url/history
     *    updateYourURL(state)
     *  })
     *  window.onpopstate(event){
     *    // This is naive though as you should check if the state is really defined etc.
     *    helper.overrideStateWithoutTriggeringChangeEvent(event.state).search()
     *  }
     * @chainable
     */
    overrideStateWithoutTriggeringChangeEvent(newState: Partial<SearchParameters>): this;
    /**
     * Check if an attribute has any numeric, conjunctive, disjunctive or hierarchical filters.
     * @param {string} attribute the name of the attribute
     * @return {boolean} true if the attribute is filtered by at least one value
     * @example
     * // hasRefinements works with numeric, conjunctive, disjunctive and hierarchical filters
     * helper.hasRefinements('price'); // false
     * helper.addNumericRefinement('price', '>', 100);
     * helper.hasRefinements('price'); // true
     *
     * helper.hasRefinements('color'); // false
     * helper.addFacetRefinement('color', 'blue');
     * helper.hasRefinements('color'); // true
     *
     * helper.hasRefinements('material'); // false
     * helper.addDisjunctiveFacetRefinement('material', 'plastic');
     * helper.hasRefinements('material'); // true
     *
     * helper.hasRefinements('categories'); // false
     * helper.toggleFacetRefinement('categories', 'kitchen > knife');
     * helper.hasRefinements('categories'); // true
     *
     */
    hasRefinements(attribute: string): boolean;
    /**
     * Check if a value is excluded for a specific faceted attribute. If the value
     * is omitted then the function checks if there is any excluding refinements.
     *
     * @param  {string}  facet name of the attribute for used for faceting
     * @param  {string}  [value] optional value. If passed will test that this value
       * is filtering the given facet.
     * @return {boolean} true if refined
     * @example
     * helper.isExcludeRefined('color'); // false
     * helper.isExcludeRefined('color', 'blue') // false
     * helper.isExcludeRefined('color', 'red') // false
     *
     * helper.addFacetExclusion('color', 'red');
     *
     * helper.isExcludeRefined('color'); // true
     * helper.isExcludeRefined('color', 'blue') // false
     * helper.isExcludeRefined('color', 'red') // true
     */
    isExcluded(facet: string, value: string): boolean;
    /**
     * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasRefinements}
     */
    isDisjunctiveRefined(facet: string, value: string): boolean;
    /**
     * Check if the string is a currently filtering tag.
     * @param {string} tag tag to check
     * @return {boolean}
     */
    hasTag(tag: string): boolean;
    /**
     * @deprecated since 2.4.0, see {@link AlgoliaSearchHelper#hasTag}
     */
    isTagRefined(tag: string): boolean;
    /**
     * Get the name of the currently used index.
     * @return {string}
     * @example
     * helper.setIndex('highestPrice_products').getIndex();
     * // returns 'highestPrice_products'
     */
    getIndex(): string;
    /**
     * Get the currently selected page
     * @deprecated
     * @return {number} the current page
     */
    getCurrentPage(): number | undefined;
    /**
     * Get the currently selected page
     * @function
     * @return {number} the current page
     */
    getPage: () => number | undefined;
    /**
     * Get all the tags currently set to filters the results.
     *
     * @return {string[]} The list of tags currently set.
     */
    getTags(): string[];
    /**
     * Get the list of refinements for a given attribute. This method works with
     * conjunctive, disjunctive, excluding and numerical filters.
     *
     * See also SearchResults#getRefinements
     *
     * @param {string} facetName attribute name used for faceting
     * @return {Array.<FacetRefinement|NumericRefinement>} All Refinement are objects that contain a value, and
     * a type. Numeric also contains an operator.
     * @example
     * helper.addNumericRefinement('price', '>', 100);
     * helper.getRefinements('price');
     * // [
     * //   {
     * //     "value": [
     * //       100
     * //     ],
     * //     "operator": ">",
     * //     "type": "numeric"
     * //   }
     * // ]
     * @example
     * helper.addFacetRefinement('color', 'blue');
     * helper.addFacetExclusion('color', 'red');
     * helper.getRefinements('color');
     * // [
     * //   {
     * //     "value": "blue",
     * //     "type": "conjunctive"
     * //   },
     * //   {
     * //     "value": "red",
     * //     "type": "exclude"
     * //   }
     * // ]
     * @example
     * helper.addDisjunctiveFacetRefinement('material', 'plastic');
     * // [
     * //   {
     * //     "value": "plastic",
     * //     "type": "disjunctive"
     * //   }
     * // ]
     */
    getRefinements(facetName: string): any[];
    /**
     * Return the current refinement for the (attribute, operator)
     * @param {string} attribute attribute in the record
     * @param {string} operator operator applied on the refined values
     * @return {Array.<number|number[]>} refined values
     */
    getNumericRefinement(attribute: string, operator: Operator): (number | number[])[];
    /**
     * Get the current breadcrumb for a hierarchical facet, as an array
     * @param  {string} facetName Hierarchical facet name
     * @return {array.<string>} the path as an array of string
     */
    getHierarchicalFacetBreadcrumb(facetName: string): string[];
    /**
     * Perform the underlying queries
     * @private
     * @return {undefined}
     * @fires search
     * @fires result
     * @fires error
     */
    _search(options: {
        onlyWithDerivedHelpers: boolean;
    }): void;
    /**
     * Transform the responses as sent by the server and transform them into a user
     * usable object that merge the results of all the batch requests. It will dispatch
     * over the different helper + derived helpers (when there are some).
     * @private
     * @param {array.<{SearchParameters, AlgoliaQueries, AlgoliaSearchHelper}>}
     *  state state used for to generate the request
     * @param {number} queryId id of the current request
     * @param {object} content content of the response
     * @return {undefined}
     */
    _dispatchAlgoliaResponse(states: {
        state: SearchParameters;
        queriesCount: number;
        helper: AlgoliaSearchHelper | DerivedHelper;
    }[], queryId: number, content: MultipleQueriesResponse<any>): void;
    _dispatchAlgoliaError(queryId: number, error: Error): void;
    containsRefinement(query: string, facetFilters: string[], numericFilters: string[], tagFilters: string[]): string | boolean;
    /**
     * Test if there are some disjunctive refinements on the facet
     * @private
     * @param {string} facet the attribute to test
     * @return {boolean}
     */
    _hasDisjunctiveRefinements(facet: string): boolean | undefined;
    _change(event: {
        state: SearchParameters;
        isPageReset: boolean;
    }): void;
    /**
     * Clears the cache of the underlying Algolia client.
     * @return {AlgoliaSearchHelper}
     */
    clearCache(): this;
    /**
     * Updates the internal client instance. If the reference of the clients
     * are equal then no update is actually done.
     * @param  {AlgoliaSearch} newClient an AlgoliaSearch client
     * @return {AlgoliaSearchHelper}
     */
    setClient(newClient: SearchClient): this;
    /**
     * Gets the instance of the currently used client.
     * @return {AlgoliaSearch}
     */
    getClient(): SearchClient;
    /**
     * Creates an derived instance of the Helper. A derived helper
     * is a way to request other indices synchronised with the lifecycle
     * of the main Helper. This mechanism uses the multiqueries feature
     * of Algolia to aggregate all the requests in a single network call.
     *
     * This method takes a function that is used to create a new SearchParameter
     * that will be used to create requests to Algolia. Those new requests
     * are created just before the `search` event. The signature of the function
     * is `SearchParameters -> SearchParameters`.
     *
     * This method returns a new DerivedHelper which is an EventEmitter
     * that fires the same `search`, `result` and `error` events. Those
     * events, however, will receive data specific to this DerivedHelper
     * and the SearchParameters that is returned by the call of the
     * parameter function.
     * @param {function} fn SearchParameters -> SearchParameters
     * @return {DerivedHelper}
     */
    derive(fn: ((params: SearchParameters) => SearchParameters)): DerivedHelper;
    /**
     * This method detaches a derived Helper from the main one. Prefer using the one from the
     * derived helper itself, to remove the event listeners too.
     * @private
     * @return {undefined}
     * @throws Error
     */
    detachDerivedHelper(derivedHelper: DerivedHelper): void;
    /**
     * This method returns true if there is currently at least one on-going search.
     * @return {boolean} true if there is a search pending
     */
    hasPendingRequests(): boolean;
}
export default AlgoliaSearchHelper;
