import RefinementList from './RefinementList';
declare type Operator = '=' | '>' | '>=' | '<' | '<=' | '!=';
declare type OperatorList = {
    [k in Operator]: Array<number | number[]>;
};
declare type RefinementList = {
    [facet: string]: string[];
};
declare type HierarchicalFacet = {
    name: string;
    attributes: string[];
    separator: string;
    rootPath?: string;
    sortBy: string[];
    showParentLevel: boolean;
};
declare type ValueOf<T> = T[keyof T];
/**
 * The facet list is the structure used to store the list of values used to
 * filter a single attribute.
 * @typedef {string[]} SearchParameters.FacetList
 */
/**
 * Structure to store numeric filters with the operator as the key. The supported operators
 * are `=`, `>`, `<`, `>=`, `<=` and `!=`.
 * @typedef {Object.<string, Array.<number|number[]>>} SearchParameters.OperatorList
 */
/**
 * SearchParameters is the data structure that contains all the information
 * usable for making a search to Algolia API. It doesn't do the search itself,
 * nor does it contains logic about the parameters.
 * It is an immutable object, therefore it has been created in a way that each
 * changes does not change the object itself but returns a copy with the
 * modification.
 * This object should probably not be instantiated outside of the helper. It will
 * be provided when needed. This object is documented for reference as you'll
 * get it from events generated by the {@link AlgoliaSearchHelper}.
 * If need be, instantiate the Helper from the factory function {@link SearchParameters.make}
 * @constructor
 * @classdesc contains all the parameters of a search
 * @param {object|SearchParameters} newParameters existing parameters or partial object
 * for the properties of a new SearchParameters
 * @see SearchParameters.make
 * @example <caption>SearchParameters of the first query in
 *   <a href="http://demos.algolia.com/instant-search-demo/">the instant search demo</a></caption>
{
   "query": "",
   "disjunctiveFacets": [
      "customerReviewCount",
      "category",
      "salePrice_range",
      "manufacturer"
  ],
   "maxValuesPerFacet": 30,
   "page": 0,
   "hitsPerPage": 10,
   "facets": [
      "type",
      "shipping"
  ]
}
 */
declare class SearchParameters {
    facets: string[];
    disjunctiveFacets: string[];
    hierarchicalFacets: HierarchicalFacet[];
    facetsRefinements: RefinementList;
    facetsExcludes: RefinementList;
    disjunctiveFacetsRefinements: RefinementList;
    numericRefinements: {
        [facet: string]: OperatorList;
    };
    tagRefinements: string[];
    hierarchicalFacetsRefinements: RefinementList;
    tagFilters?: string[];
    index: string;
    query?: string;
    page?: number;
    hitsPerPage?: number;
    typoTolerance?: 'true' | 'false' | 'min' | 'strict';
    numericFilters?: string[];
    disjunctiveRefinements?: {
        [facet: string]: string[];
    };
    aroundPrecision?: number;
    aroundRadius?: number | 'all';
    getRankingInfo?: boolean;
    minWordSizefor2Typos?: number;
    minWordSizefor1Typo?: number;
    maxValuesPerFacet?: number;
    distinct?: number | boolean;
    minimumAroundRadius?: number;
    minProximity?: number;
    insideBoundingBox?: number[][];
    constructor(newParameters?: Partial<SearchParameters>);
    /**
     * List all the properties in SearchParameters and therefore all the known Algolia properties
     * This doesn't contain any beta/hidden features.
     * @private
     */
    static PARAMETERS: string[];
    /**
     * @private
     * @param {object} partialState full or part of a state
     * @return {object} a new object with the number keys as number
     */
    static _parseNumbers: (partialState: Partial<SearchParameters>) => Partial<SearchParameters>;
    /**
     * Factory for SearchParameters
     * @param {object|SearchParameters} newParameters existing parameters or partial
     * object for the properties of a new SearchParameters
     * @return {SearchParameters} frozen instance of SearchParameters
     */
    static make(newParameters: Partial<SearchParameters>): SearchParameters;
    /**
     * Validates the new parameters based on the previous state
     * @param {SearchParameters} currentState the current state
     * @param {object|SearchParameters} parameters the new parameters to set
     * @return {Error|null} Error if the modification is invalid, null otherwise
     */
    static validate: (currentState: SearchParameters, parameters: Partial<SearchParameters>) => Error | null;
    /**
     * Remove all refinements (disjunctive + conjunctive + excludes + numeric filters)
     * @method
     * @param {undefined|string|SearchParameters.clearCallback} [attribute] optional string or function
     * - If not given, means to clear all the filters.
     * - If `string`, means to clear all refinements for the `attribute` named filter.
     * - If `function`, means to clear all the refinements that return truthy values.
     * @return {SearchParameters}
     */
    clearRefinements(attribute: string | ((value: any, key: string, refinementType?: string | undefined) => boolean)): SearchParameters;
    /**
     * Remove all the refined tags from the SearchParameters
     * @method
     * @return {SearchParameters}
     */
    clearTags(): SearchParameters;
    /**
     * Set the index.
     * @method
     * @param {string} index the index name
     * @return {SearchParameters}
     */
    setIndex(index: string): SearchParameters;
    /**
     * Query setter
     * @method
     * @param {string} newQuery value for the new query
     * @return {SearchParameters}
     */
    setQuery(newQuery: string): SearchParameters;
    /**
     * Page setter
     * @method
     * @param {number} newPage new page number
     * @return {SearchParameters}
     */
    setPage(newPage: number): SearchParameters;
    /**
     * Facets setter
     * The facets are the simple facets, used for conjunctive (and) faceting.
     * @method
     * @param {string[]} facets all the attributes of the algolia records used for conjunctive faceting
     * @return {SearchParameters}
     */
    setFacets(facets: string[]): SearchParameters;
    /**
     * Disjunctive facets setter
     * Change the list of disjunctive (or) facets the helper chan handle.
     * @method
     * @param {string[]} facets all the attributes of the algolia records used for disjunctive faceting
     * @return {SearchParameters}
     */
    setDisjunctiveFacets(facets: string[]): SearchParameters;
    /**
     * HitsPerPage setter
     * Hits per page represents the number of hits retrieved for this query
     * @method
     * @param {number} n number of hits retrieved per page of results
     * @return {SearchParameters}
     */
    setHitsPerPage(n: number): SearchParameters;
    /**
     * typoTolerance setter
     * Set the value of typoTolerance
     * @method
     * @param {string} typoTolerance new value of typoTolerance ("true", "false", "min" or "strict")
     * @return {SearchParameters}
     */
    setTypoTolerance(typoTolerance: 'true' | 'false' | 'min' | 'strict'): SearchParameters;
    /**
     * Add a numeric filter for a given attribute
     * When value is an array, they are combined with OR
     * When value is a single value, it will combined with AND
     * @method
     * @param {string} attribute attribute to set the filter on
     * @param {string} operator operator of the filter (possible values: =, >, >=, <, <=, !=)
     * @param {number | number[]} value value of the filter
     * @return {SearchParameters}
     * @example
     * // for price = 50 or 40
     * searchparameter.addNumericRefinement('price', '=', [50, 40]);
     * @example
     * // for size = 38 and 40
     * searchparameter.addNumericRefinement('size', '=', 38);
     * searchparameter.addNumericRefinement('size', '=', 40);
     */
    addNumericRefinement(attribute: string, operator: Operator, v: number | number[]): SearchParameters;
    /**
     * Get the list of conjunctive refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getConjunctiveRefinements(facetName: string): string[];
    /**
     * Get the list of disjunctive refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getDisjunctiveRefinements(facetName: string): string[];
    /**
     * Get the list of hierarchical refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getHierarchicalRefinement(facetName: string): string[];
    /**
     * Get the list of exclude refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {string[]} list of refinements
     */
    getExcludeRefinements(facetName: string): string[];
    /**
     * Remove all the numeric filter for a given (attribute, operator)
     * @method
     * @param {string} attribute attribute to set the filter on
     * @param {string} [operator] operator of the filter (possible values: =, >, >=, <, <=, !=)
     * @param {number} [number] the value to be removed
     * @return {SearchParameters}
     */
    removeNumericRefinement(attribute: string, operator: Operator, paramValue: number): SearchParameters;
    /**
     * Get the list of numeric refinements for a single facet
     * @param {string} facetName name of the attribute used for faceting
     * @return {SearchParameters.OperatorList[]} list of refinements
     */
    getNumericRefinements(facetName: string): OperatorList;
    /**
     * Return the current refinement for the (attribute, operator)
     * @param {string} attribute attribute in the record
     * @param {string} operator operator applied on the refined values
     * @return {Array.<number|number[]>} refined values
     */
    getNumericRefinement(attribute: string, operator: Operator): (number | number[])[];
    /**
     * Clear numeric filters.
     * @method
     * @private
     * @param {string|SearchParameters.clearCallback} [attribute] optional string or function
     * - If not given, means to clear all the filters.
     * - If `string`, means to clear all refinements for the `attribute` named filter.
     * - If `function`, means to clear all the refinements that return truthy values.
     * @return {Object.<string, OperatorList>}
     */
    _clearNumericRefinements(attribute?: string | ((value: {
        val: any;
        op: Operator;
    }, key: string, attr: 'numeric') => boolean)): {
        [key: string]: any;
    };
    /**
     * Add a facet to the facets attribute of the helper configuration, if it
     * isn't already present.
     * @method
     * @param {string} facet facet name to add
     * @return {SearchParameters}
     */
    addFacet(facet: string): SearchParameters;
    /**
     * Add a disjunctive facet to the disjunctiveFacets attribute of the helper
     * configuration, if it isn't already present.
     * @method
     * @param {string} facet disjunctive facet name to add
     * @return {SearchParameters}
     */
    addDisjunctiveFacet(facet: string): SearchParameters;
    /**
     * Add a hierarchical facet to the hierarchicalFacets attribute of the helper
     * configuration.
     * @method
     * @param {object} hierarchicalFacet hierarchical facet to add
     * @return {SearchParameters}
     * @throws will throw an error if a hierarchical facet with the same name was already declared
     */
    addHierarchicalFacet(hierarchicalFacet: HierarchicalFacet): SearchParameters;
    /**
     * Add a refinement on a "normal" facet
     * @method
     * @param {string} facet attribute to apply the faceting on
     * @param {string} value value of the attribute (will be converted to string)
     * @return {SearchParameters}
     */
    addFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Exclude a value from a "normal" facet
     * @method
     * @param {string} facet attribute to apply the exclusion on
     * @param {string} value value of the attribute (will be converted to string)
     * @return {SearchParameters}
     */
    addExcludeRefinement(facet: string, value: string): SearchParameters;
    /**
     * Adds a refinement on a disjunctive facet.
     * @method
     * @param {string} facet attribute to apply the faceting on
     * @param {string} value value of the attribute (will be converted to string)
     * @return {SearchParameters}
     */
    addDisjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * addTagRefinement adds a tag to the list used to filter the results
     * @param {string} tag tag to be added
     * @return {SearchParameters}
     */
    addTagRefinement(tag: string): SearchParameters;
    /**
     * Remove a facet from the facets attribute of the helper configuration, if it
     * is present.
     * @method
     * @param {string} facet facet name to remove
     * @return {SearchParameters}
     */
    removeFacet(facet: string): SearchParameters;
    /**
     * Remove a disjunctive facet from the disjunctiveFacets attribute of the
     * helper configuration, if it is present.
     * @method
     * @param {string} facet disjunctive facet name to remove
     * @return {SearchParameters}
     */
    removeDisjunctiveFacet(facet: string): SearchParameters;
    /**
     * Remove a hierarchical facet from the hierarchicalFacets attribute of the
     * helper configuration, if it is present.
     * @method
     * @param {string} facet hierarchical facet name to remove
     * @return {SearchParameters}
     */
    removeHierarchicalFacet(facet: string): SearchParameters;
    /**
     * Remove a refinement set on facet. If a value is provided, it will clear the
     * refinement for the given value, otherwise it will clear all the refinement
     * values for the faceted attribute.
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {string} [value] value used to filter
     * @return {SearchParameters}
     */
    removeFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Remove a negative refinement on a facet
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {string} value value used to filter
     * @return {SearchParameters}
     */
    removeExcludeRefinement(facet: string, value: string): SearchParameters;
    /**
     * Remove a refinement on a disjunctive facet
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {string} value value used to filter
     * @return {SearchParameters}
     */
    removeDisjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Remove a tag from the list of tag refinements
     * @method
     * @param {string} tag the tag to remove
     * @return {SearchParameters}
     */
    removeTagRefinement(tag: string): SearchParameters;
    /**
     * Generic toggle refinement method to use with facet, disjunctive facets
     * and hierarchical facets
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {SearchParameters}
     * @throws will throw an error if the facet is not declared in the settings of the helper
     * @deprecated since version 2.19.0, see {@link SearchParameters#toggleFacetRefinement}
     */
    toggleRefinement(facet: string, value: string): SearchParameters;
    /**
     * Generic toggle refinement method to use with facet, disjunctive facets
     * and hierarchical facets
     * @param  {string} facet the facet to refine
     * @param  {string} value the associated value
     * @return {SearchParameters}
     * @throws will throw an error if the facet is not declared in the settings of the helper
     */
    toggleFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleConjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleExcludeFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleDisjunctiveFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Switch the refinement applied over a facet/value
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {SearchParameters}
     */
    toggleHierarchicalFacetRefinement(facet: string, value: string): SearchParameters;
    /**
     * Adds a refinement on a hierarchical facet.
     * @param {string} facet the facet name
     * @param {string} path the hierarchical facet path
     * @return {SearchParameter} the new state
     * @throws Error if the facet is not defined or if the facet is refined
     */
    addHierarchicalFacetRefinement(facet: string, path: string): SearchParameters;
    /**
     * Removes the refinement set on a hierarchical facet.
     * @param {string} facet the facet name
     * @return {SearchParameter} the new state
     * @throws Error if the facet is not defined or if the facet is not refined
     */
    removeHierarchicalFacetRefinement(facet: string): SearchParameters;
    /**
     * Switch the tag refinement
     * @method
     * @param {string} tag the tag to remove or add
     * @return {SearchParameters}
     */
    toggleTagRefinement(tag: string): SearchParameters;
    /**
     * Test if the facet name is from one of the disjunctive facets
     * @method
     * @param {string} facet facet name to test
     * @return {boolean}
     */
    isDisjunctiveFacet(facet: string): boolean;
    /**
     * Test if the facet name is from one of the hierarchical facets
     * @method
     * @param {string} facetName facet name to test
     * @return {boolean}
     */
    isHierarchicalFacet(facetName: string): boolean;
    /**
     * Test if the facet name is from one of the conjunctive/normal facets
     * @method
     * @param {string} facet facet name to test
     * @return {boolean}
     */
    isConjunctiveFacet(facet: string): boolean;
    /**
     * Returns true if the facet is refined, either for a specific value or in
     * general.
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} value, optional value. If passed will test that this value
     * is filtering the given facet.
     * @return {boolean} returns true if refined
     */
    isFacetRefined(facet: string, value?: string): boolean;
    /**
     * Returns true if the facet contains exclusions or if a specific value is
     * excluded.
     *
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} [value] optional value. If passed will test that this value
     * is filtering the given facet.
     * @return {boolean} returns true if refined
     */
    isExcludeRefined(facet: string, value: string): boolean;
    /**
     * Returns true if the facet contains a refinement, or if a value passed is a
     * refinement for the facet.
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} value optional, will test if the value is used for refinement
     * if there is one, otherwise will test if the facet contains any refinement
     * @return {boolean}
     */
    isDisjunctiveFacetRefined(facet: string, value?: string): boolean;
    /**
     * Returns true if the facet contains a refinement, or if a value passed is a
     * refinement for the facet.
     * @method
     * @param {string} facet name of the attribute for used for faceting
     * @param {string} value optional, will test if the value is used for refinement
     * if there is one, otherwise will test if the facet contains any refinement
     * @return {boolean}
     */
    isHierarchicalFacetRefined(facet: string, value?: string): boolean;
    /**
     * Test if the triple (attribute, operator, value) is already refined.
     * If only the attribute and the operator are provided, it tests if the
     * contains any refinement value.
     * @method
     * @param {string} attribute attribute for which the refinement is applied
     * @param {string} [operator] operator of the refinement
     * @param {string} [value] value of the refinement
     * @return {boolean} true if it is refined
     */
    isNumericRefined(attribute: string, operator?: Operator, value?: number | number[]): boolean;
    /**
     * Returns true if the tag refined, false otherwise
     * @method
     * @param {string} tag the tag to check
     * @return {boolean}
     */
    isTagRefined(tag: string): boolean;
    /**
     * Returns the list of all disjunctive facets refined
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {string[]}
     */
    getRefinedDisjunctiveFacets(): string[];
    /**
     * Returns the list of all disjunctive facets refined
     * @method
     * @param {string} facet name of the attribute used for faceting
     * @param {value} value value used for filtering
     * @return {string[]}
     */
    getRefinedHierarchicalFacets(): string[];
    /**
     * Returned the list of all disjunctive facets not refined
     * @method
     * @return {string[]}
     */
    getUnrefinedDisjunctiveFacets(): string[];
    managedParameters: string[];
    getQueryParams(): {
        facets?: any;
        disjunctiveFacets?: any;
        hierarchicalFacets?: any;
        facetsRefinements?: any;
        facetsExcludes?: any;
        disjunctiveFacetsRefinements?: any;
        numericRefinements?: any;
        tagRefinements?: any;
        hierarchicalFacetsRefinements?: any;
        tagFilters?: any;
        index?: any;
        query?: any;
        page?: any;
        hitsPerPage?: any;
        typoTolerance?: any;
        numericFilters?: any;
        disjunctiveRefinements?: any;
        aroundPrecision?: any;
        aroundRadius?: any;
        getRankingInfo?: any;
        minWordSizefor2Typos?: any;
        minWordSizefor1Typo?: any;
        maxValuesPerFacet?: any;
        distinct?: any;
        minimumAroundRadius?: any;
        minProximity?: any;
        insideBoundingBox?: any;
        clearRefinements?: any;
        clearTags?: any;
        setIndex?: any;
        setQuery?: any;
        setPage?: any;
        setFacets?: any;
        setDisjunctiveFacets?: any;
        setHitsPerPage?: any;
        setTypoTolerance?: any;
        addNumericRefinement?: any;
        getConjunctiveRefinements?: any;
        getDisjunctiveRefinements?: any;
        getHierarchicalRefinement?: any;
        getExcludeRefinements?: any;
        removeNumericRefinement?: any;
        getNumericRefinements?: any;
        getNumericRefinement?: any;
        _clearNumericRefinements?: any;
        addFacet?: any;
        addDisjunctiveFacet?: any;
        addHierarchicalFacet?: any;
        addFacetRefinement?: any;
        addExcludeRefinement?: any;
        addDisjunctiveFacetRefinement?: any;
        addTagRefinement?: any;
        removeFacet?: any;
        removeDisjunctiveFacet?: any;
        removeHierarchicalFacet?: any;
        removeFacetRefinement?: any;
        removeExcludeRefinement?: any;
        removeDisjunctiveFacetRefinement?: any;
        removeTagRefinement?: any;
        toggleRefinement?: any;
        toggleFacetRefinement?: any;
        toggleConjunctiveFacetRefinement?: any;
        toggleExcludeFacetRefinement?: any;
        toggleDisjunctiveFacetRefinement?: any;
        toggleHierarchicalFacetRefinement?: any;
        addHierarchicalFacetRefinement?: any;
        removeHierarchicalFacetRefinement?: any;
        toggleTagRefinement?: any;
        isDisjunctiveFacet?: any;
        isHierarchicalFacet?: any;
        isConjunctiveFacet?: any;
        isFacetRefined?: any;
        isExcludeRefined?: any;
        isDisjunctiveFacetRefined?: any;
        isHierarchicalFacetRefined?: any;
        isNumericRefined?: any;
        isTagRefined?: any;
        getRefinedDisjunctiveFacets?: any;
        getRefinedHierarchicalFacets?: any;
        getUnrefinedDisjunctiveFacets?: any;
        managedParameters?: any;
        getQueryParams?: any;
        setQueryParameter?: any;
        setQueryParameters?: any;
        resetPage?: any;
        _getHierarchicalFacetSortBy?: any;
        _getHierarchicalFacetSeparator?: any;
        _getHierarchicalRootPath?: any;
        _getHierarchicalShowParentLevel?: any;
        getHierarchicalFacetByName?: any;
        getHierarchicalFacetBreadcrumb?: any;
        toString?: any;
    };
    /**
     * Let the user set a specific value for a given parameter. Will return the
     * same instance if the parameter is invalid or if the value is the same as the
     * previous one.
     * @method
     * @param {string} parameter the parameter name
     * @param {any} value the value to be set, must be compliant with the definition
     * of the attribute on the object
     * @return {SearchParameters} the updated state
     */
    setQueryParameter(parameter: keyof SearchParameters, value: ValueOf<SearchParameters>): SearchParameters;
    /**
     * Let the user set any of the parameters with a plain object.
     * @method
     * @param {object} params all the keys and the values to be updated
     * @return {SearchParameters} a new updated instance
     */
    setQueryParameters(params: Partial<SearchParameters>): SearchParameters;
    /**
     * Returns a new instance with the page reset. Two scenarios possible:
     * the page is omitted -> return the given instance
     * the page is set -> return a new instance with a page of 0
     * @return {SearchParameters} a new updated instance
     */
    resetPage(): SearchParameters;
    /**
     * Helper function to get the hierarchicalFacet separator or the default one (`>`)
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.separator or `>` as default
     */
    _getHierarchicalFacetSortBy(hierarchicalFacet: HierarchicalFacet): string[];
    /**
     * Helper function to get the hierarchicalFacet separator or the default one (`>`)
     * @private
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.separator or `>` as default
     */
    _getHierarchicalFacetSeparator(hierarchicalFacet?: HierarchicalFacet): string;
    /**
     * Helper function to get the hierarchicalFacet prefix path or null
     * @private
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.rootPath or null as default
     */
    _getHierarchicalRootPath(hierarchicalFacet?: HierarchicalFacet): string | null;
    /**
     * Helper function to check if we show the parent level of the hierarchicalFacet
     * @private
     * @param  {object} hierarchicalFacet
     * @return {string} returns the hierarchicalFacet.showParentLevel or true as default
     */
    _getHierarchicalShowParentLevel(hierarchicalFacet: HierarchicalFacet): boolean;
    /**
     * Helper function to get the hierarchicalFacet by it's name
     * @param  {string} hierarchicalFacetName
     * @return {object} a hierarchicalFacet
     */
    getHierarchicalFacetByName(hierarchicalFacetName: string): HierarchicalFacet | undefined;
    /**
     * Get the current breadcrumb for a hierarchical facet, as an array
     * @param  {string} facetName Hierarchical facet name
     * @return {array.<string>} the path as an array of string
     */
    getHierarchicalFacetBreadcrumb(facetName: string): string[];
    toString(): string;
}
/**
 * Callback used for clearRefinement method
 * @callback SearchParameters.clearCallback
 * @param {OperatorList|FacetList} value the value of the filter
 * @param {string} key the current attribute name
 * @param {string} type `numeric`, `disjunctiveFacet`, `conjunctiveFacet`, `hierarchicalFacet` or `exclude`
 * depending on the type of facet
 * @return {boolean} `true` if the element should be removed. `false` otherwise.
 */
export default SearchParameters;
