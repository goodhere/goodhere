{"version":3,"sources":["../../src/query/queue.js"],"names":["Queue","require","store","FastMemoryStore","queryRunner","websocketManager","GraphQLRunner","default","createBaseOptions","concurrent","Number","process","env","GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY","createBuildQueue","graphqlRunner","handler","queryJob","callback","then","result","catch","queue","createDevelopQueue","getRunner","queueOptions","priority","job","cb","id","activePaths","has","merge","oldTask","newTask","isPage","emitPageData","emitStaticQueryData","error","processBatch","jobs","activity","length","Promise","resolve","reject","taskFinishCallback","tick","on","taskFailedCallback","err","gc","drainCallback","off","forEach","push","module","exports"],"mappings":"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","sourcesContent":["const Queue = require(`better-queue`)\nconst { store } = require(`../redux`)\nconst FastMemoryStore = require(`../query/better-queue-custom-store`)\nconst queryRunner = require(`../query/query-runner`)\nconst { websocketManager } = require(`../utils/websocket-manager`)\nconst GraphQLRunner = require(`./graphql-runner`).default\n\nconst createBaseOptions = () => {\n  return {\n    concurrent: Number(process.env.GATSBY_EXPERIMENTAL_QUERY_CONCURRENCY) || 4,\n    // eslint-disable-next-line new-cap\n    store: FastMemoryStore(),\n  }\n}\n\nconst createBuildQueue = graphqlRunner => {\n  if (!graphqlRunner) {\n    graphqlRunner = new GraphQLRunner(store)\n  }\n  const handler = (queryJob, callback) =>\n    queryRunner(graphqlRunner, queryJob)\n      .then(result => callback(null, result))\n      .catch(callback)\n  const queue = new Queue(handler, createBaseOptions())\n  return queue\n}\n\nconst createDevelopQueue = getRunner => {\n  const queueOptions = {\n    ...createBaseOptions(),\n    priority: (job, cb) => {\n      if (job.id && websocketManager.activePaths.has(job.id)) {\n        cb(null, 10)\n      } else {\n        cb(null, 1)\n      }\n    },\n    merge: (oldTask, newTask, cb) => {\n      cb(null, newTask)\n    },\n  }\n\n  const handler = (queryJob, callback) => {\n    queryRunner(getRunner(), queryJob).then(\n      result => {\n        if (queryJob.isPage) {\n          websocketManager.emitPageData({\n            result,\n            id: queryJob.id,\n          })\n        } else {\n          websocketManager.emitStaticQueryData({\n            result,\n            id: queryJob.id,\n          })\n        }\n\n        callback(null, result)\n      },\n      error => callback(error)\n    )\n  }\n\n  return new Queue(handler, queueOptions)\n}\n\n/**\n * Returns a promise that pushes jobs onto queue and resolves onces\n * they're all finished processing (or rejects if one or more jobs\n * fail)\n * Note: queue is reused in develop so make sure to thoroughly cleanup hooks\n */\nconst processBatch = async (queue, jobs, activity) => {\n  if (jobs.length === 0) {\n    return Promise.resolve()\n  }\n\n  return new Promise((resolve, reject) => {\n    let taskFinishCallback\n    if (activity.tick) {\n      taskFinishCallback = () => activity.tick()\n      queue.on(`task_finish`, taskFinishCallback)\n    }\n\n    const taskFailedCallback = (...err) => {\n      gc()\n      reject(err)\n    }\n\n    const drainCallback = () => {\n      gc()\n      resolve()\n    }\n\n    const gc = () => {\n      queue.off(`task_failed`, taskFailedCallback)\n      queue.off(`drain`, drainCallback)\n      if (taskFinishCallback) {\n        queue.off(`task_finish`, taskFinishCallback)\n      }\n      queue = null\n    }\n\n    queue\n      // Note: the first arg is the path, the second the error\n      .on(`task_failed`, taskFailedCallback)\n      // Note: `drain` fires when all tasks _finish_\n      //       `empty` fires when queue is empty (but tasks are still running)\n      .on(`drain`, drainCallback)\n\n    jobs.forEach(job => queue.push(job))\n  })\n}\n\nmodule.exports = {\n  createBuildQueue,\n  createDevelopQueue,\n  processBatch,\n}\n"],"file":"queue.js"}