"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

exports.__esModule = true;
exports.default = void 0;

var _graphql = require("graphql");

var _lodash = require("lodash");

var nodeStore = _interopRequireWildcard(require("../db/nodes"));

var _addPageDependency = require("../redux/actions/add-page-dependency");

var _context = _interopRequireDefault(require("../schema/context"));

var _nodeModel = require("../schema/node-model");

class GraphQLRunner {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  // TODO: convert "../schema/node-model" from Flow
  constructor(store, {
    collectStats
  } = {}) {
    this.store = store;
    const {
      schema,
      schemaCustomization
    } = this.store.getState();
    this.nodeModel = new _nodeModel.LocalNodeModel({
      nodeStore,
      schema,
      schemaComposer: schemaCustomization.composer,
      createPageDependency: _addPageDependency.createPageDependency
    });
    this.schema = schema;
    this.parseCache = new Map();
    this.validDocuments = new WeakSet();
    this.scheduleClearCache = (0, _lodash.debounce)(this.clearCache.bind(this), 5000);

    if (collectStats) {
      this.stats = {
        totalQueries: 0,
        uniqueOperations: new Set(),
        uniqueQueries: new Set(),
        totalRunQuery: 0,
        totalPluralRunQuery: 0,
        totalIndexHits: 0,
        totalNonSingleFilters: 0,
        comparatorsUsed: new Map(),
        uniqueFilterPaths: new Set(),
        uniqueSorts: new Set()
      };
    } else {
      this.stats = null;
    }
  }

  clearCache() {
    this.parseCache.clear();
    this.validDocuments = new WeakSet();
  }

  parse(query) {
    if (!this.parseCache.has(query)) {
      this.parseCache.set(query, (0, _graphql.parse)(query));
    }

    return this.parseCache.get(query);
  }

  validate(schema, document) {
    if (!this.validDocuments.has(document)) {
      const errors = (0, _graphql.validate)(schema, document);

      if (!errors.length) {
        this.validDocuments.add(document);
      }

      return errors;
    }

    return [];
  }

  getStats() {
    if (this.stats) {
      const comparatorsUsedObj = [];
      this.stats.comparatorsUsed.forEach((value, key) => {
        comparatorsUsedObj.push({
          comparator: key,
          amount: value
        });
      });
      return {
        totalQueries: this.stats.totalQueries,
        uniqueOperations: this.stats.uniqueOperations.size,
        uniqueQueries: this.stats.uniqueQueries.size,
        totalRunQuery: this.stats.totalRunQuery,
        totalPluralRunQuery: this.stats.totalPluralRunQuery,
        totalIndexHits: this.stats.totalIndexHits,
        totalNonSingleFilters: this.stats.totalNonSingleFilters,
        comparatorsUsed: comparatorsUsedObj,
        uniqueFilterPaths: this.stats.uniqueFilterPaths.size,
        uniqueSorts: this.stats.uniqueSorts.size
      };
    } else {
      return null;
    }
  } // eslint-disable-next-line @typescript-eslint/no-explicit-any


  query(query, context) {
    const {
      schema,
      schemaCustomization
    } = this.store.getState();

    if (this.schema !== schema) {
      this.schema = schema;
      this.clearCache();
    }

    if (this.stats) {
      this.stats.totalQueries++;
      let statsQuery = query;

      if (typeof statsQuery !== `string`) {
        statsQuery = statsQuery.body;
      }

      this.stats.uniqueOperations.add(`${statsQuery}${JSON.stringify(context)}`);
      this.stats.uniqueQueries.add(statsQuery);
    }

    const document = this.parse(query);
    const errors = this.validate(schema, document);
    const result = errors.length > 0 ? {
      errors
    } : (0, _graphql.execute)({
      schema,
      document,
      rootValue: context,
      contextValue: (0, _context.default)({
        schema,
        schemaComposer: schemaCustomization.composer,
        context,
        customContext: schemaCustomization.context,
        nodeModel: this.nodeModel,
        stats: this.stats
      }),
      variableValues: context
    }); // Queries are usually executed in batch. But after the batch is finished
    // cache just wastes memory without much benefits.
    // TODO: consider a better strategy for cache purging/invalidation

    this.scheduleClearCache();
    return Promise.resolve(result);
  }

}

exports.default = GraphQLRunner;
//# sourceMappingURL=graphql-runner.js.map