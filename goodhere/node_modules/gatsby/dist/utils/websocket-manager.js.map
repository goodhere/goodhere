{"version":3,"sources":["../../src/utils/websocket-manager.ts"],"names":["getCachedPageData","pagePath","program","pages","store","getState","publicDir","path","join","directory","has","pageData","pageDataUtil","read","result","id","err","Error","undefined","hashPaths","paths","map","update","digest","getCachedStaticQueryResults","resultsMap","cachedStaticQueryResults","Map","staticQueryComponents","forEach","staticQueryComponent","hash","filePath","fileResult","fs","readFileSync","console","log","componentPath","set","JSON","parse","getRoomNameFromPath","WebsocketManager","Set","server","staticQueryResults","websocket","on","socket","activePath","handshake","headers","referer","url","activePaths","add","connectedClients","send","type","payload","errors","message","errorID","leaveRoom","leave","leftRoom","sockets","adapter","rooms","length","delete","getDataForPath","pageResults","why","get","telemetry","trackCli","siteMeasurements","clientsCount","Array","from","debounce","data","websocketManager"],"mappings":"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","sourcesContent":["import path from \"path\"\nimport { store } from \"../redux\"\nimport { Server as HTTPSServer } from \"https\"\nimport { Server as HTTPServer } from \"http\"\nimport fs from \"fs\"\nimport pageDataUtil from \"../utils/page-data\"\nimport telemetry from \"gatsby-telemetry\"\nimport url from \"url\"\nimport { createHash } from \"crypto\"\nimport { normalizePagePath, denormalizePagePath } from \"./normalize-page-path\"\nimport socketIO from \"socket.io\"\n\ninterface IPageQueryResult {\n  id: string\n  result: any // TODO: Improve this once we understand what the type is\n}\n\ninterface IStaticQueryResult {\n  id: number\n  result: any // TODO: Improve this once we understand what the type is\n}\n\ntype PageResultsMap = Map<string, IPageQueryResult>\ntype QueryResultsMap = Map<number, IStaticQueryResult>\n\n/**\n * Get cached page query result for given page path.\n * @param {string} pagePath Path to a page.\n */\nconst getCachedPageData = async (\n  pagePath: string\n): Promise<IPageQueryResult> => {\n  const { program, pages } = store.getState()\n  const publicDir = path.join(program.directory, `public`)\n  if (pages.has(denormalizePagePath(pagePath)) || pages.has(pagePath)) {\n    try {\n      const pageData = await pageDataUtil.read({ publicDir }, pagePath)\n\n      return {\n        result: pageData.result,\n        id: pagePath,\n      }\n    } catch (err) {\n      throw new Error(\n        `Error loading a result for the page query in \"${pagePath}\". Query was not run and no cached result was found.`\n      )\n    }\n  }\n\n  return {\n    id: pagePath,\n    result: undefined,\n  }\n}\n\nconst hashPaths = (paths?: string[]): undefined | Array<string | undefined> => {\n  if (!paths) {\n    return undefined\n  }\n  return paths.map(path => {\n    if (!path) {\n      return undefined\n    }\n    return createHash(`sha256`)\n      .update(path)\n      .digest(`hex`)\n  })\n}\n\n/**\n * Get cached StaticQuery results for components that Gatsby didn't run query yet.\n * @param {QueryResultsMap} resultsMap Already stored results for queries that don't need to be read from files.\n * @param {string} directory Root directory of current project.\n */\nconst getCachedStaticQueryResults = (\n  resultsMap: QueryResultsMap,\n  directory: string\n): QueryResultsMap => {\n  const cachedStaticQueryResults: QueryResultsMap = new Map()\n  const { staticQueryComponents } = store.getState()\n  staticQueryComponents.forEach(staticQueryComponent => {\n    // Don't read from file if results were already passed from query runner\n    if (resultsMap.has(staticQueryComponent.hash)) return\n    const filePath = path.join(\n      directory,\n      `public`,\n      `static`,\n      `d`,\n      `${staticQueryComponent.hash}.json`\n    )\n    const fileResult = fs.readFileSync(filePath, `utf-8`)\n    if (fileResult === `undefined`) {\n      console.log(\n        `Error loading a result for the StaticQuery in \"${staticQueryComponent.componentPath}\". Query was not run and no cached result was found.`\n      )\n      return\n    }\n    cachedStaticQueryResults.set(staticQueryComponent.hash, {\n      result: JSON.parse(fileResult),\n      id: staticQueryComponent.hash,\n    })\n  })\n  return cachedStaticQueryResults\n}\n\nconst getRoomNameFromPath = (path: string): string => `path-${path}`\n\nclass WebsocketManager {\n  activePaths: Set<string> = new Set()\n  connectedClients = 0\n  errors: Map<string, string> = new Map()\n  pageResults: PageResultsMap = new Map()\n  staticQueryResults: QueryResultsMap = new Map()\n  websocket: socketIO.Server | undefined\n\n  init = ({\n    directory,\n    server,\n  }: {\n    directory: string\n    server: HTTPSServer | HTTPServer\n  }): socketIO.Server => {\n    const cachedStaticQueryResults = getCachedStaticQueryResults(\n      this.staticQueryResults,\n      directory\n    )\n    this.staticQueryResults = new Map([\n      ...this.staticQueryResults,\n      ...cachedStaticQueryResults,\n    ])\n\n    this.websocket = socketIO(server)\n\n    this.websocket.on(`connection`, socket => {\n      let activePath: string | null = null\n      if (socket?.handshake?.headers?.referer) {\n        const path = url.parse(socket.handshake.headers.referer).path\n        if (path) {\n          activePath = path\n          this.activePaths.add(path)\n        }\n      }\n\n      this.connectedClients += 1\n      // Send already existing static query results\n      this.staticQueryResults.forEach(result => {\n        socket.send({\n          type: `staticQueryResult`,\n          payload: result,\n        })\n      })\n      this.errors.forEach((message, errorID) => {\n        socket.send({\n          type: `overlayError`,\n          payload: {\n            id: errorID,\n            message,\n          },\n        })\n      })\n\n      const leaveRoom = (path: string): void => {\n        socket.leave(getRoomNameFromPath(path))\n        if (!this.websocket) return\n        const leftRoom = this.websocket.sockets.adapter.rooms[\n          getRoomNameFromPath(path)\n        ]\n        if (!leftRoom || leftRoom.length === 0) {\n          this.activePaths.delete(path)\n        }\n      }\n\n      const getDataForPath = async (path: string): Promise<void> => {\n        if (!this.pageResults.has(path)) {\n          try {\n            const result = await getCachedPageData(path)\n\n            this.pageResults.set(path, result)\n          } catch (err) {\n            console.log(err.message)\n\n            return\n          }\n        }\n\n        socket.send({\n          type: `pageQueryResult`,\n          why: `getDataForPath`,\n          payload: this.pageResults.get(path),\n        })\n\n        if (this.connectedClients > 0) {\n          telemetry.trackCli(\n            `WEBSOCKET_PAGE_DATA_UPDATE`,\n            {\n              siteMeasurements: {\n                clientsCount: this.connectedClients,\n                paths: hashPaths(Array.from(this.activePaths)),\n              },\n            },\n            { debounce: true }\n          )\n        }\n      }\n\n      socket.on(`getDataForPath`, getDataForPath)\n\n      socket.on(`registerPath`, (path: string): void => {\n        socket.join(getRoomNameFromPath(path))\n        activePath = path\n        this.activePaths.add(path)\n      })\n\n      socket.on(`disconnect`, (): void => {\n        if (activePath) leaveRoom(activePath)\n        this.connectedClients -= 1\n      })\n\n      socket.on(`unregisterPath`, (path: string): void => {\n        leaveRoom(path)\n      })\n    })\n\n    return this.websocket\n  }\n\n  getSocket = (): socketIO.Server | undefined => this.websocket\n\n  emitStaticQueryData = (data: IStaticQueryResult): void => {\n    this.staticQueryResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `staticQueryResult`, payload: data })\n      if (this.connectedClients > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_STATIC_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.connectedClients,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitPageData = (data: IPageQueryResult): void => {\n    data.id = normalizePagePath(data.id)\n    this.pageResults.set(data.id, data)\n\n    if (this.websocket) {\n      this.websocket.send({ type: `pageQueryResult`, payload: data })\n\n      if (this.connectedClients > 0) {\n        telemetry.trackCli(\n          `WEBSOCKET_EMIT_PAGE_DATA_UPDATE`,\n          {\n            siteMeasurements: {\n              clientsCount: this.connectedClients,\n              paths: hashPaths(Array.from(this.activePaths)),\n            },\n          },\n          { debounce: true }\n        )\n      }\n    }\n  }\n\n  emitError = (id: string, message?: string): void => {\n    if (message) {\n      this.errors.set(id, message)\n    } else {\n      this.errors.delete(id)\n    }\n\n    if (this.websocket) {\n      this.websocket.send({ type: `overlayError`, payload: { id, message } })\n    }\n  }\n}\n\nexport const websocketManager: WebsocketManager = new WebsocketManager()\n"],"file":"websocket-manager.js"}