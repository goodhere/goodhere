{"version":3,"sources":["../../src/redux/run-sift.js"],"names":["default","sift","require","prepareRegex","makeRe","toDottedFields","objectToDottedField","liftResolvedFields","createDbQueriesFromObject","prefixResolvedFields","dbQueryToSiftQuery","ensureIndexByTypedChain","getNodesByTypedChain","addResolvedNodes","getNode","siftGetNode","createTypedFilterCacheKey","typeNames","filter","f","comparator","paths","push","path","type","q","nestedQuery","query","join","prepareQueryArgs","filterFields","Object","keys","reduce","acc","key","value","_","isPlainObject","getFilters","filters","map","isEqId","siftArgs","length","id","handleFirst","nodes","index","isEmpty","findIndex","$and","handleMany","result","runFlatFiltersWithoutSift","nodeTypeNames","typedKeyValueIndexes","caches","getBucketsForFilters","undefined","sort","a","b","needles","pop","forEach","node","every","cache","has","chain","targetValue","cacheKey","nodesByKeyValue","runFilterAndSort","args","queryArgs","resolvedFields","firstOnly","stats","applyFilters","sortNodes","exports","runSift","filterStats","filterToStats","comparatorPath","comparatorsUsed","set","get","uniqueFilterPaths","add","filterPath","totalNonSingleFilters","filterWithoutSift","totalIndexHits","slice","filterWithSift","concat","some","typeName","_runSiftOnNodes","runSiftOnNodes","siftFilter","$eq","internal","includes","dottedFields","dottedFieldKeys","sortFields","fields","field","startsWith","sortFns","v","sortOrder","order","toLowerCase","sortField","uniqueSorts","orderBy"],"mappings":"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","sourcesContent":["// @flow\n\nconst { default: sift } = require(`sift`)\nconst { prepareRegex } = require(`../utils/prepare-regex`)\nconst { makeRe } = require(`micromatch`)\nimport { getValueAt } from \"../utils/get-value-at\"\nimport _ from \"lodash\"\nconst {\n  toDottedFields,\n  objectToDottedField,\n  liftResolvedFields,\n  createDbQueriesFromObject,\n  prefixResolvedFields,\n  dbQueryToSiftQuery,\n} = require(`../db/common/query`)\nconst {\n  ensureIndexByTypedChain,\n  getNodesByTypedChain,\n  addResolvedNodes,\n  getNode: siftGetNode,\n} = require(`./nodes`)\n\n/**\n * Creates a key for the filterCache\n *\n * @param {Array<string>} typeNames\n * @param {DbQuery} filter\n * @returns {FilterCacheKey} (a string: `types.join()/path.join()/operator` )\n */\nconst createTypedFilterCacheKey = (typeNames, filter) => {\n  // Note: while `elemMatch` is a special case, in the key it's just `elemMatch`\n  // (This function is future proof for elemMatch support, won't receive it yet)\n  let f = filter\n  let comparator = ``\n  let paths /*: Array<string>*/ = []\n  while (f) {\n    paths.push(...f.path)\n    if (f.type === `elemMatch`) {\n      let q /*: IDbQueryElemMatch*/ = f\n      f = q.nestedQuery\n    } else {\n      let q /*: IDbQueryQuery*/ = f\n      comparator = q.query.comparator\n      break\n    }\n  }\n\n  // Note: the separators (`,` and `/`) are arbitrary but must be different\n  return typeNames.join(`,`) + `/` + comparator + `/` + paths.join(`,`)\n}\n\n/////////////////////////////////////////////////////////////////////\n// Parse filter\n/////////////////////////////////////////////////////////////////////\n\nconst prepareQueryArgs = (filterFields = {}) =>\n  Object.keys(filterFields).reduce((acc, key) => {\n    const value = filterFields[key]\n    if (_.isPlainObject(value)) {\n      acc[key === `elemMatch` ? `$elemMatch` : key] = prepareQueryArgs(value)\n    } else {\n      switch (key) {\n        case `regex`:\n          acc[`$regex`] = prepareRegex(value)\n          break\n        case `glob`:\n          acc[`$regex`] = makeRe(value)\n          break\n        default:\n          acc[`$${key}`] = value\n      }\n    }\n    return acc\n  }, {})\n\nconst getFilters = filters =>\n  Object.keys(filters).map(key => {\n    return { [key]: filters[key] }\n  })\n\n/////////////////////////////////////////////////////////////////////\n// Run Sift\n/////////////////////////////////////////////////////////////////////\n\nfunction isEqId(siftArgs) {\n  // The `id` of each node is invariably unique. So if a query is doing id $eq(string) it can find only one node tops\n  return (\n    siftArgs.length > 0 &&\n    siftArgs[0].id &&\n    Object.keys(siftArgs[0].id).length === 1 &&\n    Object.keys(siftArgs[0].id)[0] === `$eq`\n  )\n}\n\nfunction handleFirst(siftArgs, nodes) {\n  if (nodes.length === 0) {\n    return []\n  }\n\n  const index = _.isEmpty(siftArgs)\n    ? 0\n    : nodes.findIndex(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  if (index !== -1) {\n    return [nodes[index]]\n  } else {\n    return []\n  }\n}\n\nfunction handleMany(siftArgs, nodes) {\n  let result = _.isEmpty(siftArgs)\n    ? nodes\n    : nodes.filter(\n        sift({\n          $and: siftArgs,\n        })\n      )\n\n  return result?.length ? result : null\n}\n\n/**\n * Given the chain of a simple filter, return the set of nodes that pass the\n * filter. The chain should be a property chain leading to the property to\n * check, followed by the value to check against. Common example:\n *   `allThings(filter: { fields: { slug: { eq: $slug } } })`\n * Only nodes of given node types will be considered\n * A fast index is created if one doesn't exist yet so cold call is slower.\n * The empty result value is null if firstOnly is false, or else an empty array.\n *\n * @param {Array<DbQuery>} filters Resolved. (Should be checked by caller to exist)\n * @param {Array<string>} nodeTypeNames\n * @param {Map<FilterCacheKey, Map<string | number | boolean, Set<IGatsbyNode>>>} typedKeyValueIndexes\n * @returns {Array<IGatsbyNode> | undefined}\n */\nconst runFlatFiltersWithoutSift = (\n  filters,\n  nodeTypeNames,\n  typedKeyValueIndexes\n) => {\n  const caches = getBucketsForFilters(\n    filters,\n    nodeTypeNames,\n    typedKeyValueIndexes\n  )\n\n  if (!caches) {\n    // Let Sift take over as fallback\n    return undefined\n  }\n\n  // Put smallest last (we'll pop it)\n  caches.sort((a, b) => b.length - a.length)\n  // Iterate on the set with the fewest elements and create the intersection\n  const needles = caches.pop()\n  // Take the intersection of the retrieved caches-by-value\n  const result = []\n\n  // This _can_ still be expensive but the set of nodes should be limited ...\n  needles.forEach(node => {\n    if (caches.every(cache => cache.has(node))) {\n      // Every cache set contained this node so keep it\n      result.push(node)\n    }\n  })\n\n  // TODO: do we cache this result? I'm not sure how likely it is to be reused\n  // Consider the case of {a: {eq: 5}, b: {eq: 10}}, do we cache the [5,10]\n  // case for all value pairs? How likely is that to ever be reused?\n\n  return result\n}\n\n/**\n * @param {Array<DbQuery>} filters\n * @param {Array<string>} nodeTypeNames\n * @param {Map<FilterCacheKey, Map<string | number | boolean, Set<IGatsbyNode>>>} typedKeyValueIndexes\n * @returns {Array<Set<IGatsbyNode>> | undefined} Undefined means at least one\n *   cache was not found. Must fallback to sift.\n */\nconst getBucketsForFilters = (filters, nodeTypeNames, typedKeyValueIndexes) => {\n  const caches /*: Array<Map<string|number|boolean, Set<IGatsbyNode>>>*/ = []\n\n  // Fail fast while trying to create and get the value-cache for each path\n  let every = filters.every((filter /*: DbQuery*/) => {\n    let {\n      path: chain,\n      query: { value: targetValue },\n    } = filter\n\n    let cacheKey = createTypedFilterCacheKey(nodeTypeNames, filter)\n\n    ensureIndexByTypedChain(\n      cacheKey,\n      chain,\n      nodeTypeNames,\n      typedKeyValueIndexes\n    )\n\n    const nodesByKeyValue = getNodesByTypedChain(\n      cacheKey,\n      targetValue,\n      typedKeyValueIndexes\n    )\n\n    // If we couldn't find the needle then maybe sift can, for example if the\n    // schema contained a proxy; `slug: String @proxy(from: \"slugInternal\")`\n    // There are also cases (and tests) where id exists with a different type\n    if (!nodesByKeyValue) {\n      return false\n    }\n\n    // In all other cases this must be a non-empty Set because the indexing\n    // mechanism does not create a Set unless there's a IGatsbyNode for it\n    caches.push(nodesByKeyValue)\n\n    return true\n  })\n\n  if (every) {\n    return caches\n  }\n\n  // \"failed at least one\"\n  return undefined\n}\n\n/**\n * Filters and sorts a list of nodes using mongodb-like syntax.\n *\n * @param args raw graphql query filter/sort as an object\n * @property {boolean | number | string} args.type gqlType. See build-node-types\n * @property {boolean} args.firstOnly true if you want to return only the first\n *   result found. This will return a collection of size 1. Not a single element\n * @property {{filter?: Object, sort?: Object} | undefined} args.queryArgs\n * @property {undefined | Map<FilterCacheKey, Map<string | number | boolean, Set<IGatsbyNode>>>} args.typedKeyValueIndexes\n *   May be undefined. A cache of indexes where you can look up Nodes grouped\n *   by a key: `types.join(',')+'/'+filterPath.join('+')`, which yields a Map\n *   which holds a Set of Nodes for the value that the filter is trying to eq\n *   against. If the property is `id` then there is no Set, it's just the IGatsbyNode.\n *   This object lives in query/query-runner.js and is passed down runQuery\n * @returns Collection of results. Collection will be limited to 1\n *   if `firstOnly` is true\n */\nconst runFilterAndSort = (args: Object) => {\n  const {\n    queryArgs: { filter, sort } = { filter: {}, sort: {} },\n    resolvedFields = {},\n    firstOnly = false,\n    nodeTypeNames,\n    typedKeyValueIndexes,\n    stats,\n  } = args\n\n  const result = applyFilters(\n    filter,\n    firstOnly,\n    nodeTypeNames,\n    typedKeyValueIndexes,\n    resolvedFields,\n    stats\n  )\n\n  return sortNodes(result, sort, resolvedFields, stats)\n}\n\nexports.runSift = runFilterAndSort\n\n/**\n * Applies filter. First through a simple approach, which is much faster than\n * running sift, but not as versatile and correct. If no nodes were found then\n * it falls back to filtering through sift.\n *\n * @param {Array<DbQuery> | undefined} filterFields\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param {undefined | Map<FilterCacheKey, Map<string | number | boolean, Set<IGatsbyNode>>>} typedKeyValueIndexes\n * @param resolvedFields\n * @returns {Array<IGatsbyNode> | undefined} Collection of results. Collection\n *   will be limited to 1 if `firstOnly` is true\n */\nconst applyFilters = (\n  filterFields,\n  firstOnly,\n  nodeTypeNames,\n  typedKeyValueIndexes,\n  resolvedFields,\n  stats\n) => {\n  const filters /*: Array<DbQuery>*/ = filterFields\n    ? prefixResolvedFields(\n        createDbQueriesFromObject(prepareQueryArgs(filterFields)),\n        resolvedFields\n      )\n    : []\n\n  if (stats) {\n    filters.forEach((filter /*: DbQuery*/) => {\n      const filterStats = filterToStats(filter)\n      const comparatorPath = filterStats.comparatorPath.join(`.`)\n      stats.comparatorsUsed.set(\n        comparatorPath,\n        (stats.comparatorsUsed.get(comparatorPath) || 0) + 1\n      )\n      stats.uniqueFilterPaths.add(filterStats.filterPath.join(`.`))\n    })\n    if (filters.length > 1) {\n      stats.totalNonSingleFilters++\n    }\n  }\n\n  const result = filterWithoutSift(filters, nodeTypeNames, typedKeyValueIndexes)\n  if (result) {\n    if (stats) {\n      stats.totalIndexHits++\n    }\n    if (firstOnly) {\n      return result.slice(0, 1)\n    }\n    return result\n  }\n\n  return filterWithSift(filters, firstOnly, nodeTypeNames, resolvedFields)\n}\n\nconst filterToStats = (\n  filter /*: DbQuery*/,\n  filterPath = [],\n  comparatorPath = []\n) => {\n  if (filter.type === `elemMatch`) {\n    return filterToStats(\n      filter.nestedQuery,\n      filterPath.concat(filter.path),\n      comparatorPath.concat([`elemMatch`])\n    )\n  } else {\n    return {\n      filterPath: filterPath.concat(filter.path),\n      comparatorPath: comparatorPath.concat(filter.query.comparator),\n    }\n  }\n}\n\n/**\n * Check if the filter is \"flat\" (single leaf) and an \"$eq\". If so, uses custom\n * indexes based on filter and types and returns any result it finds.\n * If conditions are not met or no nodes are found, returns undefined.\n *\n * @param {Array<DbQuery>} filters Resolved. (Should be checked by caller to exist)\n * @param {Array<string>} nodeTypeNames\n * @param {Map<FilterCacheKey, Map<string | number | boolean, Set<IGatsbyNode>>>} typedKeyValueIndexes\n * @returns {Array|undefined} Collection of results\n */\nconst filterWithoutSift = (filters, nodeTypeNames, typedKeyValueIndexes) => {\n  // This can also be `$ne`, `$in` or any other grapqhl comparison op\n  if (\n    !typedKeyValueIndexes ||\n    filters.length === 0 || // TODO: we should special case this\n    filters.some(\n      filter => filter.type === `elemMatch` || filter.query.comparator !== `$eq`\n    )\n  ) {\n    return undefined\n  }\n\n  return runFlatFiltersWithoutSift(filters, nodeTypeNames, typedKeyValueIndexes)\n}\n\n// Not a public API\nexports.filterWithoutSift = filterWithoutSift\n\n/**\n * Use sift to apply filters\n *\n * @param {Array<DbQuery>} filters Resolved\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param resolvedFields\n * @returns {Array<IGatsbyNode> | undefined | null} Collection of results.\n *   Collection will be limited to 1 if `firstOnly` is true\n */\nconst filterWithSift = (filters, firstOnly, nodeTypeNames, resolvedFields) => {\n  let nodes /*: IGatsbyNode[]*/ = []\n  nodeTypeNames.forEach(typeName => addResolvedNodes(typeName, nodes))\n\n  return _runSiftOnNodes(\n    nodes,\n    filters.map(f => dbQueryToSiftQuery(f)),\n    firstOnly,\n    nodeTypeNames,\n    resolvedFields,\n    siftGetNode\n  )\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n * Note: this entry point is used by GATSBY_DB_NODES=loki\n *\n * @param {Array<IGatsbyNode>} nodes Should be all nodes of given type(s)\n * @param args Legacy api arg, see _runSiftOnNodes\n * @param {?function(id: string): IGatsbyNode | undefined} getNode\n * @returns {Array<IGatsbyNode> | undefined | null} Collection of results.\n *   Collection will be limited to 1 if `firstOnly` is true\n */\nconst runSiftOnNodes = (nodes, args, getNode = siftGetNode) => {\n  const {\n    queryArgs: { filter } = { filter: {} },\n    firstOnly = false,\n    resolvedFields = {},\n    nodeTypeNames,\n  } = args\n\n  let siftFilter = getFilters(\n    liftResolvedFields(toDottedFields(prepareQueryArgs(filter)), resolvedFields)\n  )\n\n  return _runSiftOnNodes(\n    nodes,\n    siftFilter,\n    firstOnly,\n    nodeTypeNames,\n    resolvedFields,\n    getNode\n  )\n}\n\nexports.runSiftOnNodes = runSiftOnNodes\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n *\n * @param {Array<IGatsbyNode>} nodes Should be all nodes of given type(s)\n * @param {Array<DbQuery>} filters Resolved\n * @param {boolean} firstOnly\n * @param {Array<string>} nodeTypeNames\n * @param resolvedFields\n * @param {function(id: string): IGatsbyNode | undefined} getNode Note: this is\n *   different for loki\n * @returns {Array<IGatsbyNode> | undefined | null} Collection of results.\n *   Collection will be limited to 1 if `firstOnly` is true\n */\nconst _runSiftOnNodes = (\n  nodes,\n  filters,\n  firstOnly,\n  nodeTypeNames,\n  resolvedFields,\n  getNode\n) => {\n  // If the the query for single node only has a filter for an \"id\"\n  // using \"eq\" operator, then we'll just grab that ID and return it.\n  if (isEqId(filters)) {\n    const node = getNode(filters[0].id.$eq)\n\n    if (\n      !node ||\n      (node.internal && !nodeTypeNames.includes(node.internal.type))\n    ) {\n      if (firstOnly) {\n        return []\n      }\n      return null\n    }\n\n    return [node]\n  }\n\n  if (firstOnly) {\n    return handleFirst(filters, nodes)\n  } else {\n    return handleMany(filters, nodes)\n  }\n}\n\n/**\n * Given a list of filtered nodes and sorting parameters, sort the nodes\n *\n * @param {Array<IGatsbyNode> | undefined | null} nodes Pre-filtered list of nodes\n * @param {Object | undefined} sort Sorting arguments\n * @param resolvedFields\n * @returns {Array<IGatsbyNode> | undefined | null} Same as input, except sorted\n */\nconst sortNodes = (nodes, sort, resolvedFields, stats) => {\n  if (!sort || nodes?.length <= 1) {\n    return nodes\n  }\n\n  // create functions that return the item to compare on\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const sortFields = sort.fields.map(field => {\n    if (\n      dottedFields[field] ||\n      dottedFieldKeys.some(key => field.startsWith(key))\n    ) {\n      return `__gatsby_resolved.${field}`\n    } else {\n      return field\n    }\n  })\n  const sortFns = sortFields.map(field => v => getValueAt(v, field))\n  const sortOrder = sort.order.map(order => order.toLowerCase())\n\n  if (stats) {\n    sortFields.forEach(sortField => {\n      stats.uniqueSorts.add(sortField)\n    })\n  }\n\n  return _.orderBy(nodes, sortFns, sortOrder)\n}\n"],"file":"run-sift.js"}