{"version":3,"sources":["../../../src/db/common/query.ts"],"names":["DbComparator","DB_COMPARATOR_VALUES","Set","Object","values","isDbComparator","value","has","createDbQueriesFromObject","filter","createDbQueriesFromObjectNested","path","keys","getOwnPropertyNames","_","flatMap","key","queries","map","query","type","nestedQuery","comparator","concat","prefixResolvedFields","resolvedFields","dottedFields","objectToDottedField","dottedFieldKeys","forEach","prefixPath","join","some","dottedKey","startsWith","unshift","dbQueryToSiftQuery","result","$elemMatch","length","toDottedFields","acc","nextValue","isPlainObject","obj","pathResult","liftResolvedFields","args","finalArgs"],"mappings":"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","sourcesContent":["import * as _ from \"lodash\"\n\nexport interface IDbQueryQuery {\n  type: \"query\"\n  path: Array<string>\n  query: IDbFilterStatement\n}\n\nexport interface IDbQueryElemMatch {\n  type: \"elemMatch\"\n  path: Array<string>\n  nestedQuery: DbQuery\n}\n\nexport type DbQuery = IDbQueryQuery | IDbQueryElemMatch\n\nexport enum DbComparator {\n  EQ = `$eq`,\n  NE = `$ne`,\n  GT = `$gt`,\n  GTE = `$gte`,\n  LT = `$lt`,\n  LTE = `$lte`,\n  IN = `$in`,\n  NIN = `$nin`,\n  REGEX = `$regex`,\n  GLOB = `$glob`,\n}\n\nconst DB_COMPARATOR_VALUES: Set<string> = new Set(Object.values(DbComparator))\n\nfunction isDbComparator(value: string): value is DbComparator {\n  return DB_COMPARATOR_VALUES.has(value)\n}\n\ntype DbComparatorValue = string | number | boolean | RegExp | null\n\nexport interface IDbFilterStatement {\n  comparator: DbComparator\n  value: DbComparatorValue | Array<DbComparatorValue>\n}\n\n/**\n * Converts a nested mongo args object into array of DbQuery objects,\n * structured representation of each distinct path of the query. We convert\n * nested objects with multiple keys to separate instances.\n */\nexport function createDbQueriesFromObject(filter: object): Array<DbQuery> {\n  return createDbQueriesFromObjectNested(filter)\n}\n\nfunction createDbQueriesFromObjectNested(\n  filter: object,\n  path: Array<string> = []\n): Array<DbQuery> {\n  const keys = Object.getOwnPropertyNames(filter)\n  return _.flatMap(\n    keys,\n    (key: string): Array<DbQuery> => {\n      if (key === `$elemMatch`) {\n        const queries = createDbQueriesFromObjectNested(filter[key])\n        return queries.map(query => {\n          return {\n            type: `elemMatch`,\n            path: path,\n            nestedQuery: query,\n          }\n        })\n      } else if (isDbComparator(key)) {\n        return [\n          {\n            type: `query`,\n            path,\n            query: {\n              comparator: key,\n              value: filter[key],\n            },\n          },\n        ]\n      } else {\n        return createDbQueriesFromObjectNested(filter[key], path.concat([key]))\n      }\n    }\n  )\n}\n\nexport function prefixResolvedFields(\n  queries: Array<DbQuery>,\n  resolvedFields: object\n): Array<DbQuery> {\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.getOwnPropertyNames(dottedFields)\n  queries.forEach(query => {\n    const prefixPath = query.path.join(`.`)\n    if (\n      dottedFields[prefixPath] ||\n      (dottedFieldKeys.some(dottedKey => dottedKey.startsWith(prefixPath)) &&\n        query.type === `elemMatch`) ||\n      dottedFieldKeys.some(dottedKey => prefixPath.startsWith(dottedKey))\n    ) {\n      query.path.unshift(`__gatsby_resolved`)\n    }\n  })\n  return queries\n}\n\nexport function dbQueryToSiftQuery(query: DbQuery): object {\n  const result = {}\n  if (query.type === `elemMatch`) {\n    result[query.path.join(`.`)] = {\n      $elemMatch: dbQueryToSiftQuery(query.nestedQuery),\n    }\n  } else if (query.path.length) {\n    result[query.path.join(`.`)] = {\n      [query.query.comparator]: query.query.value,\n    }\n  } else {\n    return {\n      [query.query.comparator]: query.query.value,\n    }\n  }\n  return result\n}\n\n// Most of the below can be gone after we decide to remove loki\n\n// Converts a nested mongo args object into a dotted notation. acc\n// (accumulator) must be a reference to an empty object. The converted\n// fields will be added to it. E.g\n//\n// {\n//   internal: {\n//     type: {\n//       $eq: \"TestNode\"\n//     },\n//     content: {\n//       $regex: new MiniMatch(v)\n//     }\n//   },\n//   id: {\n//     $regex: newMiniMatch(v)\n//   }\n// }\n//\n// After execution, acc would be:\n//\n// {\n//   \"internal.type\": {\n//     $eq: \"TestNode\"\n//   },\n//   \"internal.content\": {\n//     $regex: new MiniMatch(v)\n//   },\n//   \"id\": {\n//     $regex: // as above\n//   }\n// }\nexport function toDottedFields(\n  filter: object,\n  acc: object = {},\n  path: Array<string> = []\n): object {\n  Object.keys(filter).forEach(key => {\n    const value = filter[key]\n    const nextValue = _.isPlainObject(value) && value[Object.keys(value)[0]]\n    if (key === `$elemMatch`) {\n      acc[path.join(`.`)] = { [`$elemMatch`]: toDottedFields(value) }\n    } else if (_.isPlainObject(nextValue)) {\n      toDottedFields(value, acc, path.concat(key))\n    } else {\n      acc[path.concat(key).join(`.`)] = value\n    }\n  })\n  return acc\n}\n\n// Like above, but doesn't handle $elemMatch\nexport function objectToDottedField(\n  obj: object,\n  path: Array<string> = []\n): object {\n  let result = {}\n  Object.keys(obj).forEach(key => {\n    const value = obj[key]\n    if (_.isPlainObject(value)) {\n      const pathResult = objectToDottedField(value, path.concat(key))\n      result = {\n        ...result,\n        ...pathResult,\n      }\n    } else {\n      result[path.concat(key).join(`.`)] = value\n    }\n  })\n  return result\n}\n\nexport function liftResolvedFields(\n  args: object,\n  resolvedFields: object\n): object {\n  const dottedFields = objectToDottedField(resolvedFields)\n  const dottedFieldKeys = Object.keys(dottedFields)\n  const finalArgs = {}\n  Object.keys(args).forEach(key => {\n    const value = args[key]\n    if (dottedFields[key]) {\n      finalArgs[`__gatsby_resolved.${key}`] = value\n    } else if (\n      dottedFieldKeys.some(dottedKey => dottedKey.startsWith(key)) &&\n      value.$elemMatch\n    ) {\n      finalArgs[`__gatsby_resolved.${key}`] = value\n    } else if (dottedFieldKeys.some(dottedKey => key.startsWith(dottedKey))) {\n      finalArgs[`__gatsby_resolved.${key}`] = value\n    } else {\n      finalArgs[key] = value\n    }\n  })\n  return finalArgs\n}\n"],"file":"query.js"}