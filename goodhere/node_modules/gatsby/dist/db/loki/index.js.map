{"version":3,"sources":["../../../src/db/loki/index.js"],"names":["_","require","fs","path","loki","uuidv4","customComparators","Comparators","lt","ltHelper","gt","gtHelper","aeq","aeqHelper","colls","nodeMeta","name","options","unique","indices","nodeTypes","db","ensureNodeCollections","forEach","collInfo","addCollection","startFileDb","saveFile","lokiDBOptions","Promise","resolve","reject","dbOptions","autoload","autoloadCallback","err","startInMemory","start","isString","Error","saveDir","dirname","ensureDir","saveState","saveDatabase","getDb","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst fs = require(`fs-extra`)\nconst path = require(`path`)\nconst loki = require(`lokijs`)\nconst uuidv4 = require(`uuid/v4`)\nconst customComparators = require(`./custom-comparators`)\n\n// Ensure sorting behavior matches old lodash `orderBy`\n// implementation. See `custom-comparators.js` for why.\nloki.Comparators.lt = customComparators.ltHelper\nloki.Comparators.gt = customComparators.gtHelper\nloki.Comparators.aeq = customComparators.aeqHelper\n\n// Loki is a document store with the same semantics as mongo. This\n// means there are no tables or relationships. Just a bunch of\n// collections, each with objects.\n//\n// Gatsby stores nodes in collections by splitting them up by their\n// `node.internal.type`. All nodes of a particular type go in 1\n// collection. The below `colls` object contains the metadata for\n// these collections, and the \"meta collections\" used to track them.\n//\n// You won't use these directly. They are used by the collection\n// functions in `./nodes.js`. E.g. `getTypeCollName()` and\n// `getNodeTypeCollection`\nconst colls = {\n  // Each object has keys `id` and `typeCollName`. It's a way of\n  // quickly looking up the collection that a node is contained in.\n  // E.g. { id: `someNodeId`, typeCollName: `gatsby:nodeType:myType` }\n  nodeMeta: {\n    name: `gatsby:nodeMeta`,\n    options: {\n      unique: [`id`],\n      indices: [`id`],\n    },\n  },\n  // The list of all node type collections. Each object has keys\n  // `type` and `collName` so you can quickly look up the collection\n  // name for a node type.\n  // e.g. { type: `myType`, collName: `gatsby:nodeType:myType` }\n  nodeTypes: {\n    name: `gatsby:nodeTypes`,\n    options: {\n      unique: [`type`, `collName`],\n      indices: [`type`],\n    },\n  },\n}\n\n// Must be set using `start()`\nlet db\n\n/**\n * Ensures that the collections that support nodes have been\n * created. See `colls` var in this file\n */\nfunction ensureNodeCollections(db) {\n  _.forEach(colls, collInfo => {\n    const { name, options } = collInfo\n    db.addCollection(name, options)\n  })\n}\n\nfunction startFileDb({ saveFile, lokiDBOptions = {} }) {\n  return new Promise((resolve, reject) => {\n    const dbOptions = {\n      autoload: true,\n      autoloadCallback: err => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve()\n        }\n      },\n      ...lokiDBOptions,\n    }\n    db = new loki(saveFile, dbOptions)\n  })\n}\n\nasync function startInMemory() {\n  // Use uuid purely for a random name\n  db = new loki(uuidv4())\n}\n\n/**\n * Starts a loki database. If the file already exists, it will be\n * loaded as the database state. If not, a new database will be\n * created. If `saveFile` is omitted, an in-memory DB will be created.\n *\n * @param {string} saveFile on disk file that the database will be\n * saved and loaded from. If this is omitted, an in-memory database\n * will be created instead\n * @returns {Promise} promise that is resolved once the database and\n * the existing state has been loaded (if there was an existing\n * saveFile)\n */\nasync function start({ saveFile, lokiDBOptions } = {}) {\n  if (saveFile && !_.isString(saveFile)) {\n    throw new Error(`saveFile must be a path`)\n  }\n  if (saveFile) {\n    const saveDir = path.dirname(saveFile)\n    await fs.ensureDir(saveDir)\n    await startFileDb({ saveFile, lokiDBOptions })\n  } else {\n    await startInMemory()\n  }\n  ensureNodeCollections(db)\n}\n\n// Saves the database to disk and returns a promise that will be\n// resolved once the save has finished\nfunction saveState() {\n  return new Promise((resolve, reject) => {\n    if (db) {\n      db.saveDatabase(err => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve()\n        }\n      })\n    } else {\n      reject(`No database found.`)\n    }\n  })\n}\n\n/**\n * Returns a reference to the database. If undefined, the db has not been\n * initialized yet. Call `start()`\n *\n * @returns {Object} database, or undefined\n */\nfunction getDb() {\n  return db\n}\n\nmodule.exports = {\n  start,\n  getDb,\n  colls,\n  saveState,\n}\n"],"file":"index.js"}