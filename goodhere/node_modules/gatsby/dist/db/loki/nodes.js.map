{"version":3,"sources":["../../../src/db/loki/nodes.js"],"names":["_","require","invariant","getDb","colls","makeTypeCollName","type","createNodeTypeCollection","collName","nodeTypesColl","getCollection","nodeTypes","name","insert","options","unique","indices","disableMeta","coll","addCollection","getTypeCollName","nodeTypeInfo","by","undefined","getNodeTypeCollection","typeCollName","deleteNodeTypeCollections","force","find","nodeType","count","removeCollection","remove","deleteAll","db","nodeMeta","clear","getNode","id","nodeMetaColl","typeColl","getNodesByType","typeName","chain","simplesort","data","getNodes","getTypes","flatMap","map","getNodeAndSavePathDependency","path","node","nodeId","hasNodeChanged","digest","internal","contentDigest","createNode","oldNode","deleteNode","nodeTypeColl","updateNode","obj","findAndRemove","deleteNodes","nodes","saveResolvedNodes","nodeTypeNames","resolver","resolved","Promise","all","__gatsby_resolved","nodeColl","update","fieldUsages","FIELD_INDEX_THRESHOLD","ensureFieldIndexes","lokiArgs","sortArgs","emitter","on","field","forEach","v","fieldName","n","get","ensureIndex","reducer","state","Map","action","payload","fullNodes","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst invariant = require(`invariant`)\nconst { getDb, colls } = require(`./index`)\nimport { createPageDependency } from \"../../redux/actions/add-page-dependency\"\n\n// ///////////////////////////////////////////////////////////////////\n// Node collection metadata\n// ///////////////////////////////////////////////////////////////////\n\nfunction makeTypeCollName(type) {\n  return `gatsby:nodeType:${type}`\n}\n\n/**\n * Creates a collection that will contain nodes of a certain type. The\n * name of the collection for type `MyType` will be something like\n * `gatsby:nodeType:MyType` (see `makeTypeCollName`)\n */\nfunction createNodeTypeCollection(type) {\n  const collName = makeTypeCollName(type)\n  const nodeTypesColl = getDb().getCollection(colls.nodeTypes.name)\n  invariant(nodeTypesColl, `Collection ${colls.nodeTypes.name} should exist`)\n  nodeTypesColl.insert({ type, collName })\n  // TODO what if `addCollection` fails? We will have inserted into\n  // nodeTypesColl but no collection will exist. Need to make this\n  // into a transaction\n  const options = {\n    unique: [`id`],\n    indices: [`id`, `internal.counter`],\n    disableMeta: true,\n  }\n  const coll = getDb().addCollection(collName, options)\n  return coll\n}\n\n/**\n * Returns the name of the collection that contains nodes of the\n * specified type, where type is the node's `node.internal.type`\n */\nfunction getTypeCollName(type) {\n  const nodeTypesColl = getDb().getCollection(colls.nodeTypes.name)\n  invariant(nodeTypesColl, `Collection ${colls.nodeTypes.name} should exist`)\n  const nodeTypeInfo = nodeTypesColl.by(`type`, type)\n  return nodeTypeInfo ? nodeTypeInfo.collName : undefined\n}\n\n/**\n * Returns a reference to the collection that contains nodes of the\n * specified type, where type is the node's `node.internal.type`\n */\nfunction getNodeTypeCollection(type) {\n  const typeCollName = getTypeCollName(type)\n  let coll\n  if (typeCollName) {\n    coll = getDb().getCollection(typeCollName)\n    invariant(\n      coll,\n      `Type [${type}] Collection doesn't exist for nodeTypeInfo: [${typeCollName}]`\n    )\n    return coll\n  } else {\n    return undefined\n  }\n}\n\n/**\n * Deletes all empty node type collections, unless `force` is true, in\n * which case it deletes the collections even if they have nodes in\n * them\n */\nfunction deleteNodeTypeCollections(force = false) {\n  const nodeTypesColl = getDb().getCollection(colls.nodeTypes.name)\n  // find() returns all objects in collection\n  const nodeTypes = nodeTypesColl.find()\n  for (const nodeType of nodeTypes) {\n    const coll = getDb().getCollection(nodeType.collName)\n    if (coll.count() === 0 || force) {\n      getDb().removeCollection(coll.name)\n      nodeTypesColl.remove(nodeType)\n    }\n  }\n}\n\n/**\n * Deletes all nodes from all the node type collections, including the\n * id -> type metadata. There will be no nodes related data in loki\n * after this is called\n */\nfunction deleteAll() {\n  const db = getDb()\n  if (db) {\n    deleteNodeTypeCollections(true)\n    db.getCollection(colls.nodeMeta.name).clear()\n  }\n}\n\n// ///////////////////////////////////////////////////////////////////\n// Queries\n// ///////////////////////////////////////////////////////////////////\n\n/**\n * Returns the node with `id` == id, or null if not found\n */\nfunction getNode(id) {\n  if (!id) {\n    return null\n  }\n  // First, find out which collection the node is in\n  const nodeMetaColl = getDb().getCollection(colls.nodeMeta.name)\n  invariant(nodeMetaColl, `nodeMeta collection should exist`)\n  const nodeMeta = nodeMetaColl.by(`id`, id)\n  if (nodeMeta) {\n    // Now get the collection and query it by the `id` field, which\n    // has an index on it\n    const { typeCollName } = nodeMeta\n    const typeColl = getDb().getCollection(typeCollName)\n    invariant(\n      typeColl,\n      `type collection ${typeCollName} referenced by nodeMeta but doesn't exist`\n    )\n    return typeColl.by(`id`, id)\n  } else {\n    return undefined\n  }\n}\n\n/**\n * Returns all nodes of a type (where `typeName ==\n * node.internal.type`). This is an O(1) operation since nodes are\n * already stored in separate collections by type\n */\nfunction getNodesByType(typeName) {\n  invariant(typeName, `typeName is null`)\n  const collName = getTypeCollName(typeName)\n  const coll = getDb().getCollection(collName)\n  if (!coll) return []\n  return coll\n    .chain()\n    .simplesort(`internal.counter`)\n    .data()\n}\n\n/**\n * Returns the collection of all nodes. This should be deprecated and\n * `getNodesByType` should be used instead. Or at least where possible\n */\nfunction getNodes() {\n  const nodeTypes = getTypes()\n  return _.flatMap(nodeTypes, nodeType => getNodesByType(nodeType))\n}\n\n/**\n * Returns the unique collection of all node types\n */\nfunction getTypes() {\n  const nodeTypes = getDb().getCollection(colls.nodeTypes.name).data\n  return nodeTypes.map(nodeType => nodeType.type)\n}\n\n/**\n * Looks up the node by id, records a dependency between the node and\n * the path, and then returns the node\n *\n * @param {string} id node id to lookup\n * @param {string} path the page path to record a node dependency\n * against\n * @returns {Object} node or undefined if not found\n */\nfunction getNodeAndSavePathDependency(id, path) {\n  invariant(id, `id is null`)\n  invariant(id, `path is null`)\n  const node = getNode(id)\n  createPageDependency({ path, nodeId: id })\n  return node\n}\n\n/**\n * Determine if node has changed (by comparing its\n * `internal.contentDigest`\n *\n * @param {string} id\n * @param {string} digest\n * @returns {boolean}\n */\nfunction hasNodeChanged(id, digest) {\n  const node = getNode(id)\n  if (!node) {\n    return true\n  } else {\n    return node.internal.contentDigest !== digest\n  }\n}\n\n// /////////////////////////////////////////////////////////////////\n// Create/Update/Delete\n// ///////////////////////////////////////////////////////////////////\n\n/**\n * Creates a node in the DB. Will create a collection for the node\n * type if one hasn't been created yet\n *\n * @param {Object} node The node to add. Must have an `id` and\n * `internal.type`\n */\nfunction createNode(node, oldNode) {\n  invariant(node.internal, `node has no \"internal\" field`)\n  invariant(node.internal.type, `node has no \"internal.type\" field`)\n  invariant(node.id, `node has no \"id\" field`)\n\n  const type = node.internal.type\n\n  // Loki doesn't provide \"upsert\", so if the node already exists, we\n  // delete and then create it\n  if (oldNode) {\n    deleteNode(oldNode)\n  }\n\n  let nodeTypeColl = getNodeTypeCollection(type)\n  if (!nodeTypeColl) {\n    nodeTypeColl = createNodeTypeCollection(type)\n  }\n\n  const nodeMetaColl = getDb().getCollection(colls.nodeMeta.name)\n  invariant(nodeMetaColl, `Collection ${colls.nodeMeta.name} should exist`)\n  nodeMetaColl.insert({ id: node.id, typeCollName: nodeTypeColl.name })\n  // TODO what if this insert fails? We will have inserted the id ->\n  // collName mapping, but there won't be any nodes in the type\n  // collection. Need to create a transaction around this\n  return nodeTypeColl.insert(node)\n}\n\n/**\n * Updates a node in the DB. The contents of `node` will completely\n * overwrite value in the DB. Note, `node` must be a loki node. i.e it\n * has `$loki` and `meta` fields.\n *\n * @param {Object} node The new node information. This should be all\n * the node information. Not just changes\n */\nfunction updateNode(node) {\n  invariant(node.internal, `node has no \"internal\" field`)\n  invariant(node.internal.type, `node has no \"internal.type\" field`)\n  invariant(node.id, `node has no \"id\" field`)\n\n  const oldNode = getNode(node.id)\n  return createNode(node, oldNode)\n}\n\n/**\n * Deletes a node from its type collection and removes its id ->\n * collName mapping. Function is idempotent. If the node has already\n * been deleted, this is a noop.\n *\n * @param {Object} the node to delete. Must have an `id` and\n * `internal.type`\n */\nfunction deleteNode(node) {\n  invariant(node.internal, `node has no \"internal\" field`)\n  invariant(node.internal.type, `node has no \"internal.type\" field`)\n  invariant(node.id, `node has no \"id\" field`)\n\n  const type = node.internal.type\n\n  const nodeTypeColl = getNodeTypeCollection(type)\n  if (!nodeTypeColl) {\n    invariant(\n      nodeTypeColl,\n      `${type} collection doesn't exist. When trying to delete`\n    )\n  }\n\n  const obj = nodeTypeColl.by(`id`, node.id)\n  if (obj) {\n    const nodeMetaColl = getDb().getCollection(colls.nodeMeta.name)\n    invariant(nodeMetaColl, `Collection ${colls.nodeMeta.name} should exist`)\n    nodeMetaColl.findAndRemove({ id: node.id })\n    // TODO What if this `remove()` fails? We will have removed the id\n    // -> collName mapping, but not the actual node in the\n    // collection. Need to make this into a transaction\n    nodeTypeColl.remove(obj)\n  }\n  // idempotent. Do nothing if node wasn't already in DB\n}\n\n/**\n * deprecated\n */\nfunction deleteNodes(nodes) {\n  for (const node of nodes) {\n    deleteNode(node)\n  }\n}\n\nconst saveResolvedNodes = async (nodeTypeNames, resolver) => {\n  for (const typeName of nodeTypeNames) {\n    const nodes = getNodesByType(typeName)\n    const resolved = await Promise.all(\n      nodes.map(async node => {\n        node.__gatsby_resolved = await resolver(node)\n        return node\n      })\n    )\n    const nodeColl = getNodeTypeCollection(typeName)\n    if (nodeColl) {\n      nodeColl.update(resolved)\n    }\n  }\n}\n\n// Cleared on DELETE_CACHE\nlet fieldUsages = null\nconst FIELD_INDEX_THRESHOLD = 5\n\n// Every time we run a query, we increment a counter for each of its\n// fields, so that we can determine which fields are used the\n// most. Any time a field is seen more than `FIELD_INDEX_THRESHOLD`\n// times, we create a loki index so that future queries with that\n// field will execute faster.\n// times, we create a loki index so that future queries with that\n// field will execute faster.\nfunction ensureFieldIndexes(typeName, lokiArgs, sortArgs) {\n  if (fieldUsages == null) {\n    fieldUsages = {}\n    const { emitter } = require(`../../redux`)\n\n    emitter.on(`DELETE_CACHE`, () => {\n      for (const field in fieldUsages) {\n        delete fieldUsages[field]\n      }\n    })\n  }\n\n  const nodeColl = getNodeTypeCollection(typeName)\n\n  if (!fieldUsages[typeName]) {\n    fieldUsages[typeName] = {}\n  }\n\n  _.forEach(lokiArgs, (v, fieldName) => {\n    // Increment the usages of the field\n    _.update(fieldUsages[typeName], fieldName, n => (n ? n + 1 : 1))\n    // If we have crossed the threshold, then create the index\n    if (_.get(fieldUsages[typeName], fieldName) >= FIELD_INDEX_THRESHOLD) {\n      // Loki ensures that this is a noop if index already exists. E.g\n      // if it was previously added via a sort field\n      nodeColl.ensureIndex(fieldName)\n    }\n  })\n}\n\n// ///////////////////////////////////////////////////////////////////\n// Reducer\n// ///////////////////////////////////////////////////////////////////\n\nfunction reducer(state = new Map(), action) {\n  switch (action.type) {\n    case `DELETE_CACHE`:\n      deleteAll()\n      return null\n\n    case `CREATE_NODE`: {\n      createNode(action.payload, action.oldNode)\n      return null\n    }\n\n    case `ADD_FIELD_TO_NODE`:\n    case `ADD_CHILD_NODE_TO_PARENT_NODE`:\n      updateNode(action.payload)\n      return null\n\n    case `DELETE_NODE`: {\n      if (action.payload) {\n        deleteNode(action.payload)\n      }\n      return null\n    }\n\n    case `DELETE_NODES`: {\n      deleteNodes(action.fullNodes)\n      return null\n    }\n\n    default:\n      return null\n  }\n}\n\n// ///////////////////////////////////////////////////////////////////\n// Exports\n// ///////////////////////////////////////////////////////////////////\n\nmodule.exports = {\n  getNodeTypeCollection,\n\n  getNodes,\n  getNode,\n  getNodesByType,\n  getTypes,\n  hasNodeChanged,\n  getNodeAndSavePathDependency,\n\n  createNode,\n  updateNode,\n  deleteNode,\n\n  deleteNodeTypeCollections,\n  deleteAll,\n\n  reducer,\n\n  saveResolvedNodes,\n  ensureFieldIndexes,\n}\n"],"file":"nodes.js"}