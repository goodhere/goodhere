"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutPropertiesLoose2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _safeSharp = _interopRequireDefault(require("./safe-sharp"));

var _gatsbyCoreUtils = require("gatsby-core-utils");

var _common = require("./common");

_safeSharp.default.simd(true); // Handle Sharp's concurrency based on the Gatsby CPU count
// See: http://sharp.pixelplumbing.com/en/stable/api-utility/#concurrency
// See: https://www.gatsbyjs.org/docs/multi-core-builds/


_safeSharp.default.concurrency((0, _gatsbyCoreUtils.cpuCoreCount)());

function generateIcon(_x, _x2) {
  return _generateIcon.apply(this, arguments);
}

function _generateIcon() {
  _generateIcon = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(icon, srcIcon) {
    var imgPath, size, density;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            imgPath = _path.default.join("public", icon.src); // console.log(`generating icon: `, icon.src)
            // if (fs.existsSync(imgPath)) {
            //   console.log(`icon already Exists, not regenerating`)
            //   return true
            // }

            size = parseInt(icon.sizes.substring(0, icon.sizes.lastIndexOf("x"))); // For vector graphics, instruct sharp to use a pixel density
            // suitable for the resolution we're rasterizing to.
            // For pixel graphics sources this has no effect.
            // Sharp accept density from 1 to 2400

            density = Math.min(2400, Math.max(1, size));
            return _context3.abrupt("return", (0, _safeSharp.default)(srcIcon, {
              density: density
            }).resize({
              width: size,
              height: size,
              fit: "contain",
              background: {
                r: 255,
                g: 255,
                b: 255,
                alpha: 0
              }
            }).toFile(imgPath));

          case 4:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _generateIcon.apply(this, arguments);
}

function checkCache(_x3, _x4, _x5, _x6, _x7) {
  return _checkCache.apply(this, arguments);
}

function _checkCache() {
  _checkCache = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(cache, icon, srcIcon, srcIconDigest, callback) {
    var cacheKey, created;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            cacheKey = (0, _gatsbyCoreUtils.createContentDigest)("" + icon.src + srcIcon + srcIconDigest);
            created = cache.get(cacheKey, srcIcon);

            if (created) {
              _context4.next = 15;
              break;
            }

            cache.set(cacheKey, true);
            _context4.prev = 4;
            _context4.next = 7;
            return callback(icon, srcIcon);

          case 7:
            _context4.next = 13;
            break;

          case 9:
            _context4.prev = 9;
            _context4.t0 = _context4["catch"](4);
            cache.set(cacheKey, false);
            throw _context4.t0;

          case 13:
            _context4.next = 15;
            break;

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[4, 9]]);
  }));
  return _checkCache.apply(this, arguments);
}

exports.onPostBootstrap = /*#__PURE__*/function () {
  var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref3, _ref) {
    var reporter, parentSpan, basePath, localize, manifest, activity, cache, locales;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reporter = _ref3.reporter, parentSpan = _ref3.parentSpan, basePath = _ref3.basePath;
            localize = _ref.localize, manifest = (0, _objectWithoutPropertiesLoose2.default)(_ref, ["localize"]);
            activity = reporter.activityTimer("Build manifest and related icons", {
              parentSpan: parentSpan
            });
            activity.start();
            cache = new Map();
            _context.next = 7;
            return makeManifest({
              cache: cache,
              reporter: reporter,
              pluginOptions: manifest,
              basePath: basePath
            });

          case 7:
            if (!Array.isArray(localize)) {
              _context.next = 11;
              break;
            }

            locales = [].concat(localize);
            _context.next = 11;
            return Promise.all(locales.map(function (locale) {
              var cacheModeOverride = {};
              /* localization requires unique filenames for output files if a different src Icon is defined.
                 otherwise one language would override anothers icons in automatic mode.
              */

              if (locale.hasOwnProperty("icon") && !locale.hasOwnProperty("icons")) {
                // console.debug(`OVERRIDING CACHE BUSTING`, locale)
                cacheModeOverride = {
                  cache_busting_mode: "name"
                };
              }

              return makeManifest({
                cache: cache,
                reporter: reporter,
                pluginOptions: (0, _extends2.default)({}, manifest, {}, locale, {}, cacheModeOverride),
                shouldLocalize: true,
                basePath: basePath
              });
            }));

          case 11:
            activity.end();

          case 12:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function (_x8, _x9) {
    return _ref2.apply(this, arguments);
  };
}();
/**
 * The complete Triforce, or one or more components of the Triforce.
 * @typedef {Object} makeManifestArgs
 * @property {Object} cache - from gatsby-node api
 * @property {Object} reporter - from gatsby-node api
 * @property {Object} pluginOptions - from gatsby-node api/gatsby config
 * @property {boolean?} shouldLocalize
 * @property {string?} basePath - string of base path frpvided by gatsby node
 */

/**
 * Build manifest
 * @param {makeManifestArgs}
 */


var makeManifest = /*#__PURE__*/function () {
  var _ref4 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(_ref5) {
    var cache, reporter, pluginOptions, _ref5$shouldLocalize, shouldLocalize, _ref5$basePath, basePath, icon, manifest, suffix, paths, sharpIcon, metadata, cacheMode, iconDigest;

    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cache = _ref5.cache, reporter = _ref5.reporter, pluginOptions = _ref5.pluginOptions, _ref5$shouldLocalize = _ref5.shouldLocalize, shouldLocalize = _ref5$shouldLocalize === void 0 ? false : _ref5$shouldLocalize, _ref5$basePath = _ref5.basePath, basePath = _ref5$basePath === void 0 ? "" : _ref5$basePath;
            icon = pluginOptions.icon, manifest = (0, _objectWithoutPropertiesLoose2.default)(pluginOptions, ["icon"]);
            suffix = shouldLocalize && pluginOptions.lang ? "_" + pluginOptions.lang : ""; // Delete options we won't pass to the manifest.webmanifest.

            delete manifest.plugins;
            delete manifest.legacy;
            delete manifest.theme_color_in_head;
            delete manifest.cache_busting_mode;
            delete manifest.crossOrigin;
            delete manifest.icon_options;
            delete manifest.include_favicon; // If icons are not manually defined, use the default icon set.

            if (!manifest.icons) {
              manifest.icons = [].concat(_common.defaultIcons);
            } // Specify extra options for each icon (if requested).


            if (pluginOptions.icon_options) {
              manifest.icons = manifest.icons.map(function (icon) {
                return (0, _extends2.default)({}, pluginOptions.icon_options, {}, icon);
              });
            } // Determine destination path for icons.


            paths = {};
            manifest.icons.forEach(function (icon) {
              var iconPath = _path.default.join("public", _path.default.dirname(icon.src));

              if (!paths[iconPath]) {
                var exists = _fs.default.existsSync(iconPath); //create destination directory if it doesn't exist


                if (!exists) {
                  _fs.default.mkdirSync(iconPath);
                }

                paths[iconPath] = true;
              }
            }); // Only auto-generate icons if a src icon is defined.

            if (!(icon !== undefined)) {
              _context2.next = 31;
              break;
            }

            if ((0, _common.doesIconExist)(icon)) {
              _context2.next = 17;
              break;
            }

            throw new Error("icon (" + icon + ") does not exist as defined in gatsby-config.js. Make sure the file exists relative to the root of the site.");

          case 17:
            sharpIcon = (0, _safeSharp.default)(icon);
            _context2.next = 20;
            return sharpIcon.metadata();

          case 20:
            metadata = _context2.sent;

            if (metadata.width !== metadata.height) {
              reporter.warn("The icon(" + icon + ") you provided to 'gatsby-plugin-manifest' is not square.\n" + "The icons we generate will be square and for the best results we recommend you provide a square icon.\n");
            } //add cache busting


            cacheMode = typeof pluginOptions.cache_busting_mode !== "undefined" ? pluginOptions.cache_busting_mode : "query";
            iconDigest = (0, _gatsbyCoreUtils.createContentDigest)(_fs.default.readFileSync(icon)); //if cacheBusting is being done via url query icons must be generated before cache busting runs

            if (!(cacheMode === "query")) {
              _context2.next = 27;
              break;
            }

            _context2.next = 27;
            return Promise.all(manifest.icons.map(function (dstIcon) {
              return checkCache(cache, dstIcon, icon, iconDigest, generateIcon);
            }));

          case 27:
            if (cacheMode !== "none") {
              manifest.icons = manifest.icons.map(function (icon) {
                var newIcon = (0, _extends2.default)({}, icon);
                newIcon.src = (0, _common.addDigestToPath)(icon.src, iconDigest, cacheMode);
                return newIcon;
              });
            } //if file names are being modified by cacheBusting icons must be generated after cache busting runs


            if (!(cacheMode !== "query")) {
              _context2.next = 31;
              break;
            }

            _context2.next = 31;
            return Promise.all(manifest.icons.map(function (dstIcon) {
              return checkCache(cache, dstIcon, icon, iconDigest, generateIcon);
            }));

          case 31:
            //Fix #18497 by prefixing paths
            manifest.icons = manifest.icons.map(function (icon) {
              return (0, _extends2.default)({}, icon, {
                src: (0, _gatsbyCoreUtils.slash)(_path.default.join(basePath, icon.src))
              });
            });

            if (manifest.start_url) {
              manifest.start_url = _path.default.posix.join(basePath, manifest.start_url);
            } //Write manifest


            _fs.default.writeFileSync(_path.default.join("public", "manifest" + suffix + ".webmanifest"), JSON.stringify(manifest));

          case 34:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function makeManifest(_x10) {
    return _ref4.apply(this, arguments);
  };
}();

exports.onCreateWebpackConfig = function (_ref6, pluginOptions) {
  var actions = _ref6.actions,
      plugins = _ref6.plugins;
  actions.setWebpackConfig({
    plugins: [plugins.define({
      __MANIFEST_PLUGIN_HAS_LOCALISATION__: pluginOptions.localize && pluginOptions.localize.length
    })]
  });
};